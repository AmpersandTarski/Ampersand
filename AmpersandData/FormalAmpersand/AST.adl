CONTEXT RAP IN ENGLISH
--! It is allowed to change texts and/or the order of texts IF AND ONLY IF this is also done in the corresponding Haskell files !--
INCLUDE "ASTdocumentation.adl"

{-RJ/20150207: Opmerkingen n.a.v. een vluchtige code-inspectie van dit bestand
1) Het is nu nog wel, maar binnen RAP niet meer, mogelijk om een Pattern, Context en/of Concept dezelfde naam te geven (vanwege de INJectiviteit van relaties als ctxnm, ptnm). Deze nieuwe beperking lijkt me onwenselijk.
2) VIEWs (zoals 'VIEW Gen') horen m.i. niet in dit bestand thuis, maar daar waar de UI wordt gespecificeerd. IDENTs horen wel in dit bestand thuis.
3) Van "RELATION decprps[Declaration*PropertyRule]" zou ik denken dat hij niet alleen INJ, maar ook SUR moet zijn.
-}

PATTERN Context
CONCEPT Context "A context is the root of the abstract syntax tree of a valid Ampersand rule specification." 
IDENT Context: Context(ctxnm)

RELATION ctxnm[Context*Conid] [UNI,TOT,INJ]
MEANING "The name of a context."
RELATION ctxpats[Context*Pattern]
MEANING "The patterns in a context."
RELATION ctxcs[Context*PlainConcept]
MEANING "A concept, mentioned anywhere in a context, is declared."
ENDPATTERN

PATTERN Patterns
CONCEPT Pattern "A pattern is a container for relation declarations and rule definitions"
IDENT Pattern: Pattern(ptnm)

RELATION ptnm[Pattern*Conid] [UNI,TOT,INJ]
MEANING "The name of a pattern."
RELATION ptrls[Pattern*Rule]
MEANING "The user-defined rules in a pattern."
RELATION ptgns[Pattern*Gen]
MEANING "The user-defined generalization rules in a pattern."
RELATION ptdcs[Pattern*Declaration]
MEANING "The relation declarations in a pattern."
RELATION ptxps[Pattern*Blob]
MEANING "The purposes of a pattern."
ENDPATTERN

PATTERN Specialization
VIEW Gen: Gen( TXT "CLASSIFY ", genspc;cptnm , TXT " ISA " , gengen;cptnm )
RULE "eq gen": gengen;gengen~ /\ genspc;genspc~ |- I
MEANING "Two generalization rules are identical when the specific concepts are identical and the generic concepts are identical."

RELATION gengen[Gen*PlainConcept] [UNI,TOT]
MEANING "A generalization rule refers to one more generic concept."
RELATION genspc[Gen*PlainConcept] [UNI,TOT]
MEANING "A generalization rule refers to one more specific concept."

PURPOSE RULE specialization
{+Specialization has the consequence that an atom does not necessarily have one concept only.
If limes are citrus fruits, then every lime is not only lime but a citrus fruit as well.
-}
RULE specialization : in;genspc~;gengen |- in
MEANING "Every instance of a specialized concept is an instance of the generic concept too."

ENDPATTERN

PATTERN Concept
CONCEPT Concept "A concept is an abstract term representing a set of atomic terms."
IDENT PlainConcept: PlainConcept(cptnm)
CLASSIFY PlainConcept ISA Concept

RELATION cptnm[PlainConcept*Conid] [UNI,TOT,INJ]
MEANING "The name of a concept."
--RELATION cptos[Concept*AtomID] [SUR]  --HJO20150204: Deze relatie is vervangen door in~ . Dit heeft te maken met het feit dat één AtomID in meerdere concepten kan voorkomen. 
--MEANING "The population of a concept."
RELATION cptdf[PlainConcept*Blob]
MEANING "The definitions of a concept."
RELATION cptpurpose[PlainConcept*Blob]
MEANING "The purposes of a concept."
RELATION cpttp[PlainConcept*Blob]
MEANING "The (technical) type of a concept"

--CONCEPT Order "The order of the is-a-relation between concepts."
--IDENT Order: Order(ordername)
--
--RELATION ordername[Order*String] [UNI,TOT,INJ]
--MEANING "The name of a class of is-a-related concepts."
--RELATION order[Concept*Order] [UNI,TOT]
--MEANING "A concept belongs to a class of is-a-related concepts."
--RULE "order": order~;genspc~;gengen;order |- I
--MEANING "Is-a-related concepts belong to the same class of is-a-related concepts."
--RULE "different order": ???, a closure would be nice...
--MEANING "Concepts, that are not is-a-related, are in different orders of the is-a-relation."

--NOTE: MESSAGEs depend on the edit possibilities of the interface they are used in.
--if you have written messages for interfaces at a certain moment and you add an interface which can violate a message differently, then you should revise those messages, but probably you will forget to do so->risk for awkward messages in new interface
--RULE "referential integrity": src~;decsgn~;decpopu;left \/ trg~;decsgn~;decpopu;right |- order;order~;cptos
--MEANING "An atom in the domain or codomain of a relation is an instance of a concept from the same class as the source respectively the target of that relation."
--MESSAGE "If an atom is in some tuple of a relation, then that atom must exist in the concept that is the source respectively target of that relation. Deletion of an atom from a concept is not permitted if that atom is still present in some tuple of some relation. Nor is addition of a tuple permitted if the source or target atom is not present in the related concept. It is a violation of <b>Referential integrity</b> rule for a relation." 
--VIOLATION (TXT "The tuple ", SRC I, TXT " refers to a source or target atom that does not exist." )
ENDPATTERN

PATTERN Atoms
{-TODO: Documenteren! Het idee is grofweg als volgt:
Een AtomID is een element in een Concept. Elk element heeft een waarde. Een element kan echter voorkomen in verschillende concepten, namelijk indien de een een generalisatie is van de ander.
Als René in de verzameling Man zit, Man is een specialisatie van Persoon, dan zit diezelfde René ook in de verzameling Persoon. Er kan echter ook een René bestaan in de verzameling Hond. De hond René is echter iets anders dan de Persoon René. 
-}
RELATION atmRoot [AtomID*PlainConcept] [TOT]  -- most generic concept(s) where the AtomID is in. 
RELATION in[AtomID*PlainConcept] [TOT]
RELATION atomvalue[AtomID*AtomValue] [UNI,TOT]

MEANING "The value of an atom."
--RULE "entity integrity concept": atomvalue;atomvalue~ /\ cptos~;order;order~;cptos |- I
--MEANING "An atom of a concept has a unique value within the class of that concept."
--MESSAGE "Every atom of a concept is unique, or, no two atoms in the population of a concept have the same name. Addition of a duplicate atom is not permitted. It is a violation of the <b>Entity integrity</b> rule for this concept. Please refer to book <i>Rule Based Design</i>, page 43 and 52, <i>entity integrity</i>. "
--VIOLATION (TXT "An atom with name ", SRC I, TXT " already exists." )

ENDPATTERN

PATTERN Sign
VIEW Sign: Sign( TXT "[" , src;cptnm , TXT "*" , trg;cptnm , TXT "]" )

RELATION sign[Declaration*Sign] [UNI,TOT]
RELATION in[PairID*Declaration] [UNI,TOT]

RELATION src[Sign*Concept] [UNI,TOT]
MEANING "The source of a sign."
RELATION trg[Sign*Concept] [UNI,TOT]
MEANING "The target of a sign."

VIEW PairID: PairID( TXT "<" , left;atomvalue , TXT "*" , right;atomvalue , TXT ">" )
RELATION sign[PairID*Sign] [UNI,TOT]
MEANING "The sign of a relationship"
RELATION left[PairID*AtomID] [UNI,TOT]
MEANING "The source of a relationship."
RELATION right[PairID*AtomID] [UNI,TOT]
MEANING "The target of a relationship."

RELATION subsgn[Sign*Sign]
MEANING "The relation subsgn represents a partial order on signatures."

PURPOSE RULE "type consistency"
{+In Ampersand, every pair has a signature.
For example, the pair $\langle\id{Pete},5\rangle$ may have the signature $[\id{Person},\id{Rank}]$.
Ampersand is called a type consistent language, because every pair in a relation has the same signature as the relation itself.
For instance, as long as $\id{Person}$ and $\id{Rank}$ are different concepts,
the pairs $\langle\id{Pete},5\rangle$ and $\langle5,\id{Pete}\rangle$ cannot be in the same relation.

In a compiler, type consistency is ensured by a type system.
In a repository, the type of any expression does not depend on the contents of the relations in it.
As a consequence, the type of an expression can be computed based on the types of its constituent relations only.
-}
RULE "type consistency" : sign=in[PairID*Declaration];sign
MEANING "Type consistency means that all pairs in a relation have the same signature."
ENDPATTERN

PATTERN Declaration
VIEW Declaration: Declaration( decnm , TXT "::", decsgn;src;cptnm ,TXT " * ", decsgn;trg;cptnm )
--IDENT Declaration: Declaration( decnm, decsgn;src;cptnm, decsgn;trg;cptnm )
RULE "eq declaration": decnm;decnm~ /\ decsgn;src;(decsgn;src)~ /\ decsgn;trg;(decsgn;trg)~ |- I
MEANING "The unique signature of a relation consists of a relation name, a source concept, and a target concept."

RELATION decnm[Declaration*Varid] [UNI,TOT]
MEANING "The name of a relation."
RELATION decsgn[Declaration*Sign] [UNI,TOT]
MEANING "The sign of a declaration."
RELATION decprps[Declaration*PropertyRule] [INJ]
MEANING "The properties of a relation."

CONCEPT PropertyRule "A property rule is a rule, that is a property of a user-declared relation"
SPEC PropertyRule ISA Rule
CONCEPT Property "..->.. or UNI<|>TOT<|>INJ<|>SUR<|>RFX<|>IRF<|>SYM<|>ASY<|>TRN<|>PROP"
RULE "property enum": I[Property] |- '->' \/ 'UNI' \/ 'TOT' \/ 'INJ' \/ 'SUR' \/ 'RFX' \/ 'IRF' \/ 'SYM' \/ 'ASY' \/ 'TRN' \/ 'PROP'
MEANING "There are eleven tokens, that can be used to define properties on a relation. -> means univalent and total; UNI means univalent; TOT means total; INJ means injective; SUR means surjective; RFX means reflexive; IRF means irreflexive; SYM means symmetric; ASY means antisymmetric; TRN means transitive; and PROP means symmetric and antisymmetric."
RELATION declaredthrough[PropertyRule*Property] [TOT]
MEANING "A property is defined as part of the declaration of relation."

RELATION decprL[Declaration*String] [UNI]
MEANING "The prefix of the pragma of a relation."
RELATION decprM[Declaration*String] [UNI]
MEANING "The infix of the pragma of a relation."
RELATION decprR[Declaration*String] [UNI]
MEANING "The suffix of the pragma of a relation."
RELATION decmean[Declaration * Blob]
MEANING "The meanings of a relation."
RELATION decpurpose[Declaration * Blob]
MEANING "The purposes of a relation."
RELATION decpopu[Declaration*PairID]
MEANING "The population of a relation."

RULE "entity integrity of relation": left;left~ /\ right;right~ /\ decpopu~;decpopu |- I
MEANING "There cannot be two relationships in the population of a relation with the same source and same target."
MESSAGE "Every tuple in a relation is unique, or, no two tuples in the population of a relation may have the same source and target atoms. Addition of a duplicate tuple is not permitted. It is a violation of the <b>Entity integrity</b> rule for this relation."
VIOLATION (TXT "A tuple with the same source and target atoms ", SRC I, TXT " already exists." )

--RULE "typed domain": decpopu;left;cptos~;order  |- decsgn;src;order
--MEANING "The atoms in the domain of a relation belong to the same class as the source of that relation."
--MESSAGE "You try to add a tuple with a source atom, that is not in the population of the source of the relation. This is a violation of the type of the tuple. TIP: enter text in the left input field to get a shorter pick list. Note on ISA-relations: You can make an atom more specific by moving it to the population of a more specific concept."
--VIOLATION (TXT "Source atom ", TGT I, TXT " is not in the population of ", SRC decsgn;src)

--RULE "typed codomain": decpopu;right;cptos~;order |- decsgn;trg;order
--MEANING "The atoms in the codomain of a relation belong to the same class as the target of that relation."
--MESSAGE "You try to add a tuple with a target atom, that is not in the population of the target of the relation. This is a violation of the type of the tuple. TIP: enter text in the right input field to get a shorter pick list. Note on ISA-relations: You can make an atom more specific by moving it to the population of a more specific concept."
--VIOLATION (TXT "Target atom ", TGT I, TXT " is not in the population of ", SRC decsgn;trg)
ENDPATTERN

PATTERN Expression
IDENT ExpressionID : ExpressionID(exprvalue)

RELATION exprvalue[ExpressionID*Expression] [UNI,TOT]
MEANING "The value of an expression."
RELATION relsMentionedIn[ExpressionID*Declaration]
MEANING "The user-declared relations in an expression."

CLASSIFY RelationRef ISA Expression

CONCEPT RelationRef "A relation reference (aka relation token) is an expression that refers to a user-declared relation"
VIEW RelationRef: RelationRef( relnm , TXT "[" , relsgn;src;cptnm , TXT "*" , relsgn;trg;cptnm , TXT "]")

RELATION relnm[RelationRef*Varid] [UNI,TOT]
MEANING "A relation reference has the name of the relation that is being referred to."
RELATION relsgn[RelationRef*Sign] [UNI,TOT]
MEANING "A relation reference has the sign of the relation that is being referred to."
RELATION reldcl[RelationRef*Declaration] [UNI,TOT]
MEANING "A relation reference has the relation that is being referred to."
RULE "rel name is decl name": relnm = reldcl;decnm
MEANING "A relation reference has the same name as the relation to which it refers."
RULE "rel sign sub of decl sign": reldcl = relnm;decnm~ /\ relsgn;subsgn;decsgn~
MEANING "A relation reference refers to the relation with the same name, the signature of which is larger or equal to the signature of the relation reference."
ENDPATTERN

PATTERN Rules
IDENT Rule: Rule(rrnm)

RELATION rrnm[Rule*ADLid] [UNI,TOT,INJ]
MEANING "The name of a rule."
RELATION rrexp[Rule*ExpressionID] [UNI,TOT]
MEANING "The rule expressed in relation algebra."
RELATION rrmean[Rule * Blob]
MEANING "The meanings of a rule."
RELATION rrpurpose[Rule * Blob]
MEANING "The purposes of a rule."
ENDPATTERN

PATTERN Plugs -- This pattern documents the semantics of plugs as of november 2014.
RELATION sign[Rule*Sign] [UNI,TOT]
RELATION maintains[Plug*Rule]
RELATION in[PlainConcept*Plug] [UNI,TOT]
RELATION in[Declaration*Plug] [UNI,TOT]

-- Rules
RULE "rule allocation" : maintains;rrexp;relsMentionedIn |- in~
MEANING "A plug, which maintains a rule, must contain every relation that is mentioned explicitly in that rule."

RULE "All isas in one plug" : (-(genspc~;gengen;in) \/ in) /\ (-(gengen~;genspc;in) \/ in)
MEANING "If a concept is stored in a plug, then every generalization of that concept is stored in the same plug."
ENDPATTERN

PATTERN ToDo -- This pattern contains stuff still to be done.
RELATION rrviols[Rule*Violation]
ENDPATTERN
ENDCONTEXT


