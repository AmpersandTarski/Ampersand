CONTEXT AST IN ENGLISH LATEX
INCLUDE "Tables.adl"

PURPOSE CONCEPT PlugInfo
{+Ampersand uses PlugInfos to store a set of records.
One particular implementation of a PlugInfo is a table in a relational database.
However, this pattern generalizes to other persistent structures, hence the name "PlugInfo".
The current implementation uses tables from a relational database for this purpose.
-}

PURPOSE PATTERN Persistence
{+This pattern describes how pairs can be stored in a persistent storage system (PSS), such as a relational database.
The assumption is that the elements of a pair are stored in fields of a record, and records are stored in a table-like structure called PlugInfo.
This pattern guarantees a sound definition of the relation in[Pair*Relation].
In doing so, the specification leaves certain choices open for the implementation.
They can be made for reasons of performance, for instance.
These choices considered to be outside the scope of this pattern.
This pattern only defines the relation ``in[Pair*Relation] in terms of PlugInfos.
The challenge is to translate a partial order of concepts together with a set of binary relations to a PlugInfo.
-}
PURPOSE CONCEPT Field
{+A record contains fields in which atoms can be stored. If a field contains no atom, we call it empty. There can be at most one atom in a field.
-}
PURPOSE CONCEPT Record
{+A PlugInfo contains records, each of which can store multiple pairs.
The purpose of a record is to store facts about a single object.
A reservation record is an example, in which facts about one particular reservation are stored in one record.
-}
PURPOSE CONCEPT Field
{+A record contains fields in which atoms can be stored. If a field contains no atom, we call it empty. There can be at most one atom in a field.
-}
PURPOSE RELATION val[Field*Atom]
{+Which atom resides in a particula field is determined by the relation `val`.
It is not total. It contains a pair `(f,a)` only if field `f` contains atom `a`.-}

PURPOSE RELATION val[Field*Atom]
{+
-}
RELATION val[Field*Atom] [UNI] -- the record in which a field resides
MEANING "The relation `val` determines which atom is stored in any particular field."
PURPOSE RELATION in[Record*PlugInfo]
{+
-}
PURPOSE RELATION rec[Field*Record]
{+
-}
RELATION rec[Field*Record] [UNI,TOT] -- the record in which a field resides
MEANING ""
PURPOSE RELATION att[Field*SqlAttribute]
{+
-}
RELATION att[Field*SqlAttribute] [UNI,TOT] -- the attribute in which a field resides
MEANING ""
RELATION in[Record*PlugInfo] [UNI,TOT] -- the record in which a field resides
MEANING ""
PURPOSE RELATION table[SqlAttribute*PlugInfo]
{+This function `table` exists to determine the attributes of every PlugInfo.
This knowledge can be used to generate database tables.
-}
RELATION table[SqlAttribute*PlugInfo] [UNI]
MEANING "Each SqlAttribute is a column in precisely one PlugInfo. So, the relation `table~` associates a set of SqlAttributes with every `PlugInfo`."

PURPOSE RELATION srcAtt[Relation*SqlAttribute]
{+The source and target of a relation are administered in designated attributes (i.e. columns of a table).
That column is registered in the relation srcAtt.
`srcAtt` and `tgtAtt` must be functions, i.e. univalent and total.
-}
RELATION srcAtt[Relation*SqlAttribute]
MEANING "Function `srcAtt` determines the source attribute of a relation."
RELATION tgtAtt[Relation*SqlAttribute]
MEANING "Function `tgtAtt` determines the target attribute of a relation."
PURPOSE RELATION l[Pair*Atom]
{+Functions `l` and `r` exist for the purpose of taking atoms from pairs.
-}
RELATION l[Pair*Atom] [UNI] -- should be TOT as well...
MEANING "Function `l` determines the left atom of a pair."
RELATION r[Pair*Atom] [UNI] -- should be TOT as well...
MEANING "Function `r` determines the right atom of a pair."

-- the following are duplicated from Atoms.adl
RELATION in[Pair*Relation] [UNI] -- should be TOT as well...
RELATION fst[SRFP*Field] [UNI] -- should be TOT as well...
RELATION snd[SRFP*Field] [UNI] -- should be TOT as well...

PURPOSE RULE sameTable   -- srcAtt;table = tgtAtt;table
{+The PSS must ensure that a relation is stored in attributes of the same table.
-}
PURPOSE RULE sameRecord   -- fst;rec = snd;rec
{+The PSS must ensure that every SRFP is stored in one record.
-}
PURPOSE RULE inRelation   -- in = (l;val~;fst~/\r;val~;snd~) ; (fst;att;srcAtt~/\snd;att;tgtAtt~)
{+The following rule is needed by the PSS to compute whether a pair is in a relation.
As a consequence, users can be assured that the PSS stores pairs correctly.
-}
PURPOSE RULE identifyField   -- rec;rec~/\att;att~ |- I[Field]
{+In order to retrieve atoms from fields, every field must be identified uniquely.
-}
PURPOSE RULE inTable   -- in = rec~;att;table
{+The following rule is needed by the PSS to compute whether a Record is in a PlugInfo.
As a consequence, users can be assured that the PSS stores records in the right table.
-}
CONCEPT PlugInfo "A PlugInfo is either a TblSQL or a BinSQL."
PURPOSE CONCEPT TblSQL
{+Ampersand translates the partial order of concepts to a TblSQL, which is a specific form of PlugInfo.
Relations that are either univalent or injective store its population in the same tables.
-}
CONCEPT TblSQL "A TblSQL is a table structure, meant to store the populations of one or more concepts and zero or more relations."
PURPOSE CONCEPT BinSQL
{+Relations that are neither univalent nor injective are called n-to-m relations.
Ampersand translates such relations to binary tables, called BinSQL.
-}
CONCEPT BinSQL "A BinSQL is a table structure, meant to store the population of one n-to-m relation."



PURPOSE PATTERN "Kernel Tables"
{+This pattern specifies the translation of a partially ordered set of concepts to a table structure.
That structure is called the kernel of the database tables.
It is used to define database tables for the SQL-database that stores the state (population) of the current context.
Two structures are needed: the TblSQL is a table with one or more columns.
Or, if you will, it represents an entity with one or more attributes.
A BinSQL represents a binary table. It is used to store relations that are neither UNI nor INJ, i.e. n-to-m relations.
-}
PURPOSE RELATION concept[SqlAttribute*Concept]
{+The type of an atom depends only on the table in which it is stored.
For this reason, a concept is associated with each attribute.
Every atom stored in an attribute is more specific than or equal to that concept.
-}
RELATION concept[SqlAttribute*Concept] [UNI,TOT] -- concept in a column of a (wide) table
MEANING "The system registers one concept per attribute in the relation concept. Each atom in that attribute is an instance of that concept."

PURPOSE RELATION conceptAttribute[Concept*SqlAttribute]
{+For some computations, such as the complement, it is necessary to know which atoms instantiate a concept.
So, every atom is administered in a concept table, which is stored in the relation conceptAttribute.
-}
RELATION conceptAttribute[Concept*SqlAttribute] -- alleen 'ONE' overtreedt de TOTaliteit hier, maar ONE gaat er toch uit.
MEANING "Each concept is related to the attribute (i.e. the database-table column) that contains all atoms of a given concept."
PURPOSE RULE "TOT conceptAttribute (new)"
{+The application ensures that there is a concept table for each concept, the totality of the relation conceptAttribute is maintained by the application.
In this way, the addition of a new concept will lead to the introduction of a new concept table.
-}
PURPOSE RULE "TOT conceptAttribute (del)"
{+Similarly, removal of a concept results in the removal of the corresponding concept table.
-}

PURPOSE RELATION rootConcept[TblSQL*Concept]
{+A largest concept is a concept that is not a specialization of any other concept.
Each TblSQL uses a largest concept as its key attribute.
This is called the root concept of that table.
The relation rootConcept is used to administer this fact for each TblSQL.
-}
RELATION rootConcept[TblSQL*Concept] [UNI]
MEANING "Each SQL-table has one root concept."

PURPOSE RULE "New TblSQL"
{+The application ensures that each largest concept gets a TblSQL of its own.
It stores that largest concept and all smaller concepts.
Since the order of concepts is partial, there can be many largest concepts, so there will be just as many TblSQL's.
-}
PURPOSE RULE "Del TblSQL"
{+The application removes a TblSQL when a concept ceases to exist.
-}

PURPOSE RULE "Assign attributes to tables"
{+When SqlAttributes come into existence, they must be assigned to a PlugInfo.
-}
PURPOSE RELATION key[TblSQL*SqlAttribute]
{+One of the attributes of a TblSQL is designated as key.
Its atoms can be used to identify an entire row in the TblSQL
-}
RELATION key[TblSQL*SqlAttribute] [UNI,TOT]
MEANING "Each PlugInfo has one field designated to contain atom keys."

PURPOSE RULE "Insert key of a TblSQL"
{+If the root concept of a TblSQL changes, it is necessary to change its key along.
-}




PURPOSE PATTERN "Attributes for univalent relations" LATEX
{+After translating the partial order of concepts to a table structure,
the relations must be translated
There are three different situations:
\begin{enumerate}
\item univalent relations;
\item injective relations that are not univalent;
\item relations that are neither univalent nor injective.
\end{enumerate}
Univalence means that there can be at most one target atom for every source atom.
By storing the target atom in the same database record as the source atom,
the population of a univalent relation can be kept in the same table as its source concept.
Injective relations that are not univalent can be treated symmetrically.
Relations that are neither univalent nor injective are administered separately in a BinSQL table.
-}

PURPOSE RELATION prop[Relation*Property]
{+Multiplicity properties of relations have consequences for the way Ampersand generates database tables.
For this reason, Ampersand keeps these properties in the system.
-}
RELATION prop[Relation*Property]

PURPOSE RULE "fill srcAtt for univalent relations"
{+An atom in the domain of a univalent relation has one related atom in the target (by the definition of univalence).
Therefore, the pair can be stored in the same table in which Ampersand keeps the source concept.
For this purpose, that table is expanded with one column, in which the target atoms of that relation are stored.
-}
PURPOSE RULE "fill tgtAtt for univalent relations"
{+For univalent relations of which the srcAtt is defined,
Ampersand defines the tgtAtt by introducing a new SqlAttribute.
This effectively adds one column to the table.
-}

PURPOSE RULE "fill tgtAtt for injective relations"
{+An atom in the domain of an injective relation has one related atom in the source (by the definition of injectivity).
Therefore, the pair can be stored in the same table in which Ampersand keeps the target concept.
Since univalent relations are already stored in the table of the source atom,
this rule applies only to relations that are injective and not univalent.
-}
PURPOSE RULE "fill srcAtt for injective relations"
{+For injective relations of which the tgtAtt is defined,
Ampersand defines the srcAtt by introducing a new SqlAttribute.
This effectively adds one column to the table.
-}

--PURPOSE 
--{+
---}

ENDCONTEXT 