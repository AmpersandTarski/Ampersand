CONTEXT RAP IN ENGLISH

PURPOSE PATTERN Enforcements
{+Enforcements are introduced for separating the specification of rules from their enforcements.
This relates to discussions held in Github issues #311 and #398.

In the compiler, we will introduce a data structure `Enforcement` in the A-structure:

data Enforcement =
       Block
     | Process Role
     | Implicit PA_Clause
     | Automated PA_Clause

In the Ampersand-metamodel (FormalAmpersand\Enforcements.adl) we introduce this pattern.

Definitions:
1. violation: A violation of `RULE p |- c` is a pair `(a,b)\in p` such that `(a,b)\not\in c`
2. violation: A violation of `RULE p = c` is a violation of a rule `p |- c` or violation of a rule `c |- p`.
3. satisfaction: A rule is satisfied in a context if there are no violations of that rule in that context.
4. validity of a rule: A rule `r` is valid in a context if it is supposed to be satisfied in that context.
5. validity of a rule: The declaration of a rule between the brackets `CONTEXT c` ... `ENDCONTEXT` means that the rule is valid in context `c`.
6. restoring: To restore a rule `r` that is valid in context `c` means to bring the database in a state without violations of rule `r` in context `c`.
7. maintaining: A rule is being maintained if all of its violations are being monitored continuously and it will be restored in every context in which it is valid.
8. monitoring: To monitor a rule `r` that is valid in context `c` means to compute all violations of rule `r` and signal their existence to every stakeholder of that violation.
9. validity of enforcement: The declaration of an enforcement of rule `r` can exist in a context and in an interface. If it exists in a context, it is valid throughout that context. If it exists in an interface, it is valid throughout that interface.

Any application generated by Ampersand must support that each rule that is valid in a context remains satisfied.
An enforcement represents how the application does that.
In every situation there must be precisely one enforcement on every rule.
For this reason there are default enforcements if the user fails to specify one.
There are precedence rules if the user specifies multiple enforcements.
The following rules govern the existence of enforcements:
1. Within an interface in context `c`, there may be at most one enforcement of any rule `r`. This is checked statically.
2. Within a context `c` outside interfaces (Rieks' "belly") there may be at most one enforcement of any rule `r`. This is checked statically.
3. If an enforcement of rule `r` is valid in a context `c` and if another enforcement of rule `r` is valid in an interface `i` that is declared in context `c`, then the enforcement of rule `r` in interface `i` the one that is used to maintain rule `r`.
Informally, we can say that an enforcement that is declared in an interface precedes any enforcement that is valid in the context of that interface..
So the enforcement "closest to the user" is the one being used.

The following alternatives exist:
1. Block: The rule has to remain satisfied at all times. Only within a database transaction it may be "violated temporarily" as long as the transaction remains open. Commit is possible only when the rule is satisfied. Rollback is always an option and it leaves the database in the state it was when the transaction was started. Users not involved in the transaction will never notice what has occured within the transaction; they will only see the result. I.e. the transaction behaviour you would expect from any database.
2. Automated: There is a rule, which restores satisfaction of the rule when executed by the computer. Note that other rules may be violated as a result. The rule to be executed is not just any Ampersand rule. Executable rules are called "clause" or "ECA-rule".
3. Implicit: There is a rule, which is maintained without any execution whatsoever. An example is the way univalence of relations is maintained. It requires no execution by a computer, but comes as a result of the specific choices that are made to implement the persistent store in Ampersand. An implicit rule is described as though it were an ECA-rule. The code generator generates no code, but the description can be used by analysis software such as normalizers and proof checkers.
4. Process: A human agent, represented generically by a Role, is required to restore the rule. No code for restoring the rule is generated, but code for monitoring is.
-}

PATTERN Enforcements
RELATION context[Enforcement*Context] [UNI]
RELATION in[Interface*Context] [UNI]
RELATION interface[Enforcement*Interface] [UNI]
RELATION type[Enforcement*EnforcementType] [UNI]
RELATION rule[Enforcement*Rule] [UNI]
RELATION role[Enforcement*Role] [UNI]
RELATION clause[Enforcement*PA_Clause] [UNI]
RELATION valid[Enforcement*Context] [UNI]
RELATION valid[Enforcement*Interface] [UNI]

RULE EnforcementType   : I[EnforcementType] = 'Block' \/ 'Automated' \/ 'Implicit' \/ 'Process'
MEANING "There are four types of enforcement: 'Block', 'Automated', 'Implicit', and 'Process'"
RULE EnforceRoleTot    : type;'Process'[EnforcementType];type~ /\ I[Enforcement] |- role;role~
MEANING "For every enforcement of type `Process` there exists a role."
RULE EnforceRoleUni    : role~;(type;'Process'[EnforcementType];type~ /\ I);role |-  I[Role]
MEANING "For every enforcement of type `Process` there is at most one role."
RULE EnforceClauseTot  : type;('Automated'\/'Implicit');type~ /\ I[Enforcement]     |- clause;clause~
MEANING "For every enforcement of type `Automated` or `Implicit` there exists a clause."
RULE EnforceClauseUni  : clause~;(type;('Automated'\/'Implicit');type~ /\ I);clause |-  I[PA_Clause]
MEANING "For every enforcement of type `Automated` or `Implicit` there is at most one clause."
RULE validInInterface  : valid[Enforcement*Interface] = interface \/ (context;in~/\-interface)
MEANING "An enforcement that is declared in an interface precedes any enforcement that is valid in the context of that interface."
ENDPATTERN

ENDCONTEXT