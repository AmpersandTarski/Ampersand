CONTEXT FormalAmpersand IN ENGLISH 

-- TODO add purposes for the metamodel of concepts

PATTERN Concepts
    
    CONCEPT FormalAmpersand.Rule "A rule is a statement that must be satisfied in each context in which it is valid."
    CONCEPT FormalAmpersand.ConceptDef "A conceptdef defines a concept."

    VIEW FormalAmpersand.Concept: FormalAmpersand.Concept(FormalAmpersand.name)
    RELATION FormalAmpersand.name[FormalAmpersand.Concept*FormalAmpersand.ConceptName] [TOT,SUR] --Not UNI because of aliases
      ROLE ExecEngine MAINTAINS "del unused ConceptName"
      RULE "del unused ConceptName" : I[FormalAmpersand.ConceptName] |- FormalAmpersand.name~;FormalAmpersand.name
      MEANING "A ConceptName without Concept will be removed."
      VIOLATION ( TXT "{EX} DelAtom;FormalAmpersand.ConceptName;", SRC I )
    
    IDENT FormalAmpersand.Concept : FormalAmpersand.Concept(FormalAmpersand.name,FormalAmpersand.context[FormalAmpersand.Concept*FormalAmpersand.Context])

    RELATION FormalAmpersand.name[FormalAmpersand.Relation*FormalAmpersand.RelationName] [UNI,TOT]
    MEANING "Every relation has a name by which it can be referenced within its Context(s)."
    RELATION FormalAmpersand.source[FormalAmpersand.Relation*FormalAmpersand.Concept] [UNI,TOT]
    RELATION FormalAmpersand.target[FormalAmpersand.Relation*FormalAmpersand.Concept] [UNI,TOT]

    REPRESENT FormalAmpersand.Name TYPE ALPHANUMERIC
    CLASSIFY FormalAmpersand.ConceptName, FormalAmpersand.RelationName ISA FormalAmpersand.Name
    RELATION FormalAmpersand.context[FormalAmpersand.Concept*FormalAmpersand.Context] [UNI] -- comes from concs, which is defined in FSpec. This contains all concepts declared inside a context but outside the patterns it contains.
ENDPATTERN


PATTERN FormalAmpersand.Specialization
--    VIEW Isa: Isa( TXT "CLASSIFY ", genspc;name{-[Concept*ConceptName]-} , TXT " ISA " , gengen;name{-[Concept*ConceptName]-} )
--    RULE eqGen : gengen;gengen~ /\ genspc;genspc~ |- I
--    MEANING "Two generalization rules are identical when the specific concepts are identical and the generic concepts are identical."
-- HJO, 20160906: Disabled above rule and view, because a generalisation can currently have more than one generic concepts (CLASSIFY A IS B /\ C )
    RELATION FormalAmpersand.gengen[FormalAmpersand.Isa*FormalAmpersand.Concept] [UNI,TOT]
    MEANING "A generalization rule refers to one or more generic concepts."
    RELATION FormalAmpersand.genspc[FormalAmpersand.Isa*FormalAmpersand.Concept] [UNI,TOT]
    MEANING "A generalization rule refers to one or more specific concepts."
    RELATION FormalAmpersand.gengen[FormalAmpersand.IsE*FormalAmpersand.Concept] [TOT]
    MEANING "A generalization rule refers to one or more generic concepts."
    RELATION FormalAmpersand.genspc[FormalAmpersand.IsE*FormalAmpersand.Concept] [UNI,TOT]
    MEANING "A generalization rule refers to one or more specific concepts."

--PURPOSE RULE specialization
--{+Specialization has the consequence that an atom is not necessarily an instance of one concept only.
--If limes are citrus fruits, then every lime is not only lime but a citrus fruit as well.
--+}
--RELATION instanceOf[Atom*Concept] [TOT] 
--RULE specialization : instanceOf;genspc~;gengen |- instanceOf
--MEANING "Every instance of a specialized concept is an instance of the generic concept too."

ENDPATTERN


PATTERN "Technical Types"
    PURPOSE RELATION FormalAmpersand.represent[FormalAmpersand.Concept*FormalAmpersand.TType]
    {+ Atoms are represented as integers, strings, dates, or whatever as specified by the technical type.
    Formally, this satisfies a particular algebra, i.e. the algebra of natural numbers, of strings, of dates, etc.
    Technically, the representation corresponds with the requirements of the specific technology in which the prototype is implemented (in this case as specified by ISO SQL).
    +}

    PURPOSE RULE UNIrepresent
    {+ This rule produces an error message if a concept has more than one technical type.
    The Ampersand parser must produce an error message in this case. +}

    PURPOSE RELATION FormalAmpersand.objectByDef[FormalAmpersand.Concept*FormalAmpersand.TType]
    {+ A concept used as a key by an ObjectDef must be of technical type Object. +}

    PURPOSE RELATION FormalAmpersand.tTypeByUser[FormalAmpersand.Concept*FormalAmpersand.TType]
    {+ This relation contains the technical types that are directly specified by a user:
    either by a REPRESENT statement or by using it as key in an interface BOX.
    The enforce rule ignores concepts with multiple representations to prevent superfluous error messages. +}

    PURPOSE RULE UNItTypeByUser
    {+ This rule produces an error message if a REPRESENT statement defines a technical type other than OBJECT, yet the Concept is used as key in a (sub-)interface. +}

    PURPOSE RELATION FormalAmpersand.tTypology[FormalAmpersand.Concept*FormalAmpersand.TType]
    {+ tTypology assigns one technical types to all concepts in each typology.
    The corresponding enforce rule subtracts all concepts with multiple technical types from this relation
    to get fewer superfluous error messages in RULE UNItTypology.
    +}
    
    PURPOSE RULE UNItTypology
    {+ This rule ensures that tTypology is univalent.
    To save error messages that are already signaled by RULE UNIrepresent,
    the enforce rule that populates relation tTypology subtracts all concepts with multiple technical types from this relation.
    If ttype is a univalent relation, this rule subtracts nothing and all concepts in the typology .
    +}

    PURPOSE RELATION FormalAmpersand.ttype[FormalAmpersand.Concept*FormalAmpersand.TType]
    {+ The relation ttype adds the default technical type, ALPHANUMERIC, to concepts that have not been given one by the user.
    This relation is univalent and total, which can be proven when tTypology is univalent.
    +}
ENDPATTERN


PATTERN "Compute Closures"
    RELATION isa[Concept*Concept] [ASY]
    MEANING "s isa g  means that each element of concept  s  is defined to be an element of concept  g  as well."
    RELATION isaStar[Concept*Concept] -- Transitive, reflexive closure of isa, aka isa*
    MEANING "s isaStar g  means that  s  is  g  or  each element of concept s  is an element of concept  g  as well."
    RELATION isaPlus[Concept*Concept] -- Transitive closure of isa, aka isa+
    MEANING "s isaPlus g  means that each element of concept  s  is an element of concept  g  as well."

    RELATION isaCopy[Concept*Concept] -- necessary only for calling the Transitive closure function.
    ROLE ExecEngine MAINTAINS "Compute transitive closure of isa"
    RULE "Compute transitive closure of isa" : isa[Concept*Concept] = isaCopy[Concept*Concept]
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} TransitiveClosure;isa[Concept*Concept];Concept;isaCopy[Concept*Concept];isaPlus")

    ROLE ExecEngine MAINTAINS "Compute transitive closure of isa by Ins", "Compute transitive closure of isa by Del"
    RULE "Compute transitive closure of isa by Ins" : isaPlus\/I |- isaStar
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} InsPair;isaStar;Concept;", SRC I, TXT ";Concept;", TGT I)
    RULE "Compute transitive closure of isa by Del" : isaStar |- isaPlus\/I
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} DelPair;isaStar;Concept;", SRC I, TXT ";Concept;", TGT I)
ENDPATTERN

PATTERN "Reflexive isa closures"
    RELATION isaRfxStar[Concept*Concept] -- Transitive, reflexive closure of isa[Concept*Concept]\/isa[Concept*Concept]~
    MEANING "s isaRfxStar g  means that  s  is  g  or  each element of concept s  is an element of concept  g  or vice-versa."
    RELATION isaRfxPlus[Concept*Concept] -- Transitive closure of isa[Concept*Concept]\/isa[Concept*Concept]~
    MEANING "s isaRfxPlus g  means that each element of concept  s  is an element of concept  g  or vice-versa."

    RELATION isaRfx[Concept*Concept] -- isaRfx[Concept*Concept]=isa[Concept*Concept]\/isa[Concept*Concept]~
    ROLE ExecEngine MAINTAINS "Compute isaRfxIns", "Compute isaRfxDel"
    RULE "Compute isaRfxIns" : isa[Concept*Concept]\/isa[Concept*Concept]~ |- isaRfx[Concept*Concept]
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} InsPair;isaRfx[Concept*Concept];Concept;", SRC I, TXT ";Concept;", TGT I)
    RULE "Compute isaRfxDel" : isaRfx[Concept*Concept] |- isa[Concept*Concept]\/isa[Concept*Concept]~
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} DelPair;isaRfx[Concept*Concept];Concept;", SRC I, TXT ";Concept;", TGT I)

    RELATION isaRfxCopy[Concept*Concept] -- necessary only for calling the Transitive closure function.
    ROLE ExecEngine MAINTAINS "Compute transitive closure of isa[Concept*Concept]\\/isa[Concept*Concept]~"
    RULE "Compute transitive closure of isa[Concept*Concept]\\/isa[Concept*Concept]~" : isaRfx[Concept*Concept] = isaRfxCopy[Concept*Concept]
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} TransitiveClosure;isaRfx[Concept*Concept];Concept;isaRfxCopy[Concept*Concept];isaRfxPlus[Concept*Concept]")

    ROLE ExecEngine MAINTAINS "Compute isaRfxStar by Ins", "Compute isaRfxStar by Del"
    RULE "Compute isaRfxStar by Ins" : isaRfxPlus[Concept*Concept]\/I |- isaRfxStar[Concept*Concept]
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} InsPair;isaRfxStar[Concept*Concept];Concept;", SRC I, TXT ";Concept;", TGT I)
    RULE "Compute isaRfxStar by Del" : isaRfxStar[Concept*Concept] |- isaRfxPlus[Concept*Concept]\/I
    MEANING "TODO: MEANING ONTBREEKT"
    VIOLATION (TXT "{EX} DelPair;isaRfxStar[Concept*Concept];Concept;", SRC I, TXT ";Concept;", TGT I)
ENDPATTERN
ENDCONTEXT