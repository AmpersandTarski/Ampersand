{-# LANGUAGE TemplateHaskell #-}
module GRDT.Generators (generateGRDT) where
import Data.Char
import Control.Applicative
import Data.Void
import Data.Foldable (toList)
import Data.Semigroup (Endo(..))
-- import Data.List -- unzip4 and onwards
import Language.Haskell.TH
-- import Language.Haskell.TH.Syntax
import GRDT.Data
import GRDT.Common
import qualified Data.Map as Map
-- import Data.Foldable (toList)
import Control.Monad.IO.Class
import GRDT.Parser (FDAfterParse) -- included to make the Parser.hs file compile first
import GHC.Stack (HasCallStack)
import Data.Maybe (listToMaybe)
import Data.List (nub)
-- import Control.Arrow
-- import Util(firstM) -- package ghc

-- | QExp is a wrapper around Exp so we can carry some type information.
--   For types that are generated at runtime, 'Void' is used,
--   which still allows us to match on types like: QExp 'Void -> Maybe Void'
newtype QExp a = QExp {runQExp :: Exp}       -- QExp
newtype QExpL a = QExpL {runQExpL :: [Exp]}  -- QExp List
data ListOf a
data Information
data HaskellType -- some haskell type not generated by us
data InterfaceType -- also a haskell type, but one for which we generate the interface stuff


--- Question: is this used?
instance Semigroup Information where
 _ <> _ = undefined -- no code

{-
 append two QExp type together
-}
-- Question: what is f? Dec?
apQE :: QExp (a -> b) -> QExp a -> QExp b
apQE (QExp f) (QExp v) = QExp (AppE f v)

apsQE :: QExp (ListOf a -> b) -> QExpL a -> QExp b
apsQE (QExp f) (QExpL v) = QExp (foldl AppE f v)

type FilledInterface a
 = Interface (TBGTypeInfo, a)
             (InpName, TBGTypeInfo)
             TBGTypeInfo
             (FoundDecl (InpName, [Card]) TBGTypeInfo)

type TBGTypeInfo -- ^ TBG: to be generated
     = Status ConstructorGenInfo TypeWhenFinishedInfo

data ConstructorGenInfo
  = CGI { cgiToDec :: [Type] -> Dec
        }

data ToFromInformation
  = TFI { tfiType :: Type
        , tfiConstruct :: [[Exp]] -> QExp Information
        , tfiRels :: [FoundDecl InpName TBGTypeInfo]
        }

data TypeWhenFinishedInfo
  = TWF { twfType :: Type
        , twfMakeStr :: Either (Info,Name) Name
        , twfUnmakeStr :: Either (Info,Name) Name
        , twfFromStr :: Either (Info,Name) Name
        , twfGetStr :: Either (Info,Name) Name
        , twfConstructor :: Either (Info,Name) Name
        }

-- | Track things that might be generated by our code
data Status generateInfo a
 = Exists a
 | ToBeGenerated !generateInfo a

{-
Check status and return its value
-}
runStatus :: Status a v -> v
runStatus (Exists v) = v
runStatus (ToBeGenerated _ v) = v

{-
Take InpName, lookup to see if it is a type name/value name then return generated function names
not sure what does the function f do.
-}
genStatusForType :: (Name -> ([Char] -> Q a) -> Q (Status generateInfo TypeWhenFinishedInfo))
                 -> InpName -> Q (Status generateInfo TypeWhenFinishedInfo)
genStatusForType f tp
 = do nmT <- lookupTypeName (runUP tp) -- lookupTypeName :: String -> Q (Maybe Name)
      nmV <- lookupValueName (runUP tp) -- lookupValueName :: String -> Q (Maybe Name)
      case (nmT,nmV) of
        (Just a, _) -> do info <- reify a  -- defined in TH: reify :: Name -> Q Info
                          ok <- Exists <$> genFunNames a tp
                          case info of -- Question: what is Family?
                            ClassI _ _ -> cannot "it is a class name.\n  We did not expect you to write class name here. If you intentionally wanted to use a Class here, do let us know why on our issue tracker."
                            TyConI _dec -> return ok
                            PrimTyConI _ 0 _ -> return ok -- Question: what does Arity stands for?
                            PrimTyConI _ _ _ -> cannot "it is a type already.\n  We cannot use that type because it takes arguments. Consider using a type synonym to fill in the arguments."
                            FamilyI _dec _insts -> cannot "it refers to a type family.\n We never tried this out, can you send us your code in the issue tracker?"
                            _ -> cannot "it came back as a reserved name, but we don't understand what it is.\n Can you report this as a bug in the issue tracker? (Regardless of whether there is a bug in your code: it might still help us to improve this message)"
        (Nothing, Just _)
          -> cannot "it already exists as a value.\n  If you want to use your own definition for this type, make sure it is defined in the splice." -- TODO: errmsg
        (Nothing, Nothing)
          -> let nm = mkName (runUP tp)
             in f nm cannot
 where cannot t = fail' tp (\s -> "type "++s++"\nWe cannot generate one because "++t)

{-
Generate function names for each Name
Will lookup to see if it is already a value name
Return helper function names for InpName
-}
genFunNames :: Name -> InpName -> Q (TypeWhenFinishedInfo)
-- Question: what's the difference between InpName and (UserProvided String)
-- Answer SJC: there is no difference, InpName is easier to read so please replace them
genFunNames a tp
 = do [m,g,u,f,c] <- traverse lookupV' ["make"++runUP tp, "get"++runUP tp
                                     ,"unmake"++runUP tp, "from"++runUP tp, runUP tp]
      return (TWF { twfType = ConT a
                  , twfMakeStr = m
                  , twfGetStr = g
                  , twfUnmakeStr = u
                  , twfFromStr = f
                  , twfConstructor = c
                  })
 where lookupV' str = do l <- lookupValueName str
                         case l of
                           Nothing -> return (Right (mkName str))
                           Just v -> do info <- reify v
                                        return (Left (info, v))

{-
Question: Get lost, why TWF -> TBG???
          Where does the tpName comes from?
-}
genType :: InpName -> Q TBGTypeInfo
genType inps = genStatusForType genTp inps
  where genTp tpName _ -- tpName::Name  inps::InpName Question????
          = do ok <- genFunNames tpName inps
               return $
                ToBeGenerated
                  (CGI { cgiToDec=
                          (\comps -> DataD [] tpName [] Nothing [NormalC tpName (map ((,) bang_default) comps)]
                                    [DerivClause Nothing (map ConT [''Show,''Eq,''Ord])])
                       }) ok

{-
Not sure how this function works. Same Question as last one, TWF -> TBG??
-}
lookupType :: UserProvided String -> Q TBGTypeInfo
lookupType = genStatusForType (\_ c -> c "no interface definition is available for it.\n  If you wish to use your own type definition, make sure it is defined in the splice.") -- TODO: errmsg
-- InpName ifc_info [Component com_info tp t]

-- Question: Need some explanation on those functions
addInfo :: Map.Map String t  -- data Map k a (A Map from keys k to values a.)
        -> Interface x (InpName, InpName) InpName FDAfterParse
        -> Interface (t, x) (InpName, t) t (FoundDecl (InpName, [Card]) t)
addInfo mpT (Intf nm inf cps)
 = Intf nm (conv nm, inf) (map (upd onCPType conv) cps)
 where conv = (mpT Map.!) . runUP -- (!) :: Ord k => Map k a -> k -> aSource

loopBack
        :: Map.Map String t
        -> Interface (v, InpName) b c d
        -> Interface (v, Either (Type, String) t) b c d
loopBack mp (Intf nm (ti,inm) e)
  = (Intf nm (ti, case Map.lookup (runUP inm) mp of
                    Just v -> Right v
                    Nothing -> Left (ConT (mkName (runUP inm)), runUP inm)
             ) e)

upd :: ((t -> (() -> t1)) -> a -> (() -> c)) -- ^ read "() ->" as "f" to see why this argument is a lens. Note that "() ->" and "Identity" are isomorphic (modulo bottoms?).
    -> (t -> t1) -> a -> c
upd lens f = ($ ()) . lens (\v _ -> f v)

foldrLens :: ((a -> Const (Endo b) b1) -> a3 -> Const (Endo a4) b2) -- ^ read "Const _" as "f" to see why this argument is a traversal (lens with an 'Applicative' requirement)
          -> (a -> b -> b) -> a4 -> a3 -> a4
foldrLens lens f z t = appEndo (foldMapLens lens (Endo . f) t ) z

getAll :: ((a1 -> Const (Endo [a1]) b1) -> a3 -> Const (Endo [a2]) b2) -- ^ read "Const _" as "f" to see why this argument is a traversal (lens with an 'Applicative' requirement)
       -> a3 -> [a2]
getAll lens = foldrLens lens (:) []

foldMapLens :: ((a1 -> Const a2 b1) -> a3 -> Const c b2) -- ^ read "Const _" as "f" to see why this argument is a traversal (lens with an 'Applicative' requirement)
            -> (a1 -> a2) -> a3 -> c
foldMapLens lens f = getConst . lens (Const . f)

-- | Function to generate the GRDT with its interfaces
generateGRDT :: ([Declaration], [Interface InpName (InpName, InpName) InpName FDAfterParse])
             -> Q [Dec]
generateGRDT (dlst, ilst)
 = do -- We create a list of all types that need to exist because they occur somewhere.
      -- We then ask two questions:
      -- 1. Do we have an interface to generate it with
      -- 2. Does it already exist
      -- If it does not exist and we have no interface to generate it,
      --   lookupType immediately throws an error.
      -- If it does exist, we use it
      -- Otherwise we promise to eventually generate it.
      -- The resulting declarations are called "ifc_decls'".
      let types_fromDecls = concatMap ((\(x,y) -> [x,y]) . source_target) dlst
      let types_fromIfs = concatMap (\(Intf _ _ cplst) -> concatMap (getAll onCPType) cplst) ilst
      let types_generatable = map (\(Intf nm _ _) -> nm) ilst
      let type_map' = Map.fromListWith (const id)
       -- fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map.Map k a
       -- using 'const id' has the following behavior:
       -- if elements occur twice in the same list,
       -- the last elements are ignored
       -- this is why we put the types_generatable first, and then the types
       -- that are found elsewhere but are possibly not generatable
      -- Question: which fromListWith? type seems not match
                         ([(runUP tp,genType tp) | tp <- types_generatable] ++
                          [(runUP tp,lookupType tp) | tp <- types_fromIfs ++ types_fromDecls])
      type_map <- sequence type_map'
      --
      -- We have now gathered enough information to generate the 'Information' type,
      -- and generate the types that we promised to generate.
      -- We generate the Information type first:
      (information_decls, tfi) <- information_decl type_map dlst
      putStrLn' "------ information_decl ------"
      putStrLn' (pprint information_decls)
      putStrLn' "------------------------------"
      
      -- TODO: info_imp' generation possibly removes duplicate interfaces, we should throw a nice looking error if that happens
      let info_imp' = Map.fromList (map (\x -> (runUP (getInterfaceName x), addInfo type_map x)) ilst)
      -- fromList :: Ord k => [(k, a)] -> Map k a
      let info_imp = fmap (loopBack info_imp') info_imp'

      -- Fulfill our promise to generate the types.
      -- We simultaneously generate "make", "get", "unmake" and "from".
      ifc_decls <- concat <$> traverse (ifc_data_decl tfi) info_imp
      putStrLn' "------- ifc_data_decl --------"
      putStrLn' (pprint ifc_decls)
      putStrLn' "------------------------------"

      return (concat [information_decls, ifc_decls])
  where
    putStrLn' = liftIO . putStrLn -- switch for debug outout
    -- putStrLn' _ = const (return ()) -- no debug outout

-- Define common value
bang_default :: Bang
bang_default = Bang NoSourceUnpackedness NoSourceStrictness

-- Generate ArrowT Dec
arrowt :: Type -> Type -> Type
arrowt a b = AppT (AppT ArrowT a) b

getNme :: Either (Info, Name) Name -> Name
getNme (Left (_,nm)) = nm
getNme (Right nm) = nm

-- Generate Declaration
ifc_data_decl :: ToFromInformation
              -> FilledInterface (Either (Type,String) (FilledInterface InpName))
              -> Q [Dec]
ifc_data_decl tfi (Intf ifcnm (from, to_t) cp_lst)
  = do (types, cardInfo) <- unzip <$> traverse mkCon cp_lst
       data_decl <- case from of
                      Exists _ -> return []
                      ToBeGenerated info _
                       -> return [cgiToDec info types]
       let fromT = runStatus from
       let constructor :: QExp (ListOf Void -> Void)
           constructor = QExp (ConE (mkName (runUP ifcnm)))
       let makeTypeStr = twfMakeStr fromT
       let getNm = case twfGetStr fromT of
            (Left (_info,v)) -> v -- todo: handle potential type-errors
            (Right v) -> v -- new
       make_decl
         <- case makeTypeStr of
              Left (info,v)
               -> do let checkTp _ = fail' ifcnm . const $ "Cannot use the provided function "++show v++", this is not implemented yet (our code wants to generate everything for you), but now we can't generate it either because you'd have conflicting definitions" -- TODO
                     case info of
                        VarI _nm tp' _ -> checkTp tp'
                        DataConI _nm tp' _ -> checkTp tp'
                        ClassOpI _nm _tp pcl -> fail' ifcnm . const $ "Cannot generate the function "++show v++" inside the class "++show pcl++" or check if it's present, this is not implemented yet" -- TODO
                        _ -> fail' ifcnm . const $ ("Unexpected information for the type of the existing identifier "++show v++" (please report this as a bug. To fix this, try removing your definition of "++show v++" from scope)")
              Right nameMake -> obtain_make nameMake getNm (tfiType tfi) constructor fromT to_t cardInfo
       from_funs
         <- case to_t of
              Left _ -> return [] -- TODO: check if 'unmake' is present, and still generate 'from' if so
              Right (Intf _ to_t' cp_lst_subset)
                -> do (unmake_decls,success)
                         <- gen_unmake (twfUnmakeStr fromT)
                                       (twfType fromT)
                                       (mkName (runUP ifcnm))
                                       cp_lst
                                       (twfType$ runStatus (fst to_t'))
                                       (twfConstructor $ runStatus (fst to_t'))
                                       cp_lst_subset
                      case success of
                        (Just v) -> (unmake_decls ++) <$> gen_from (twfFromStr fromT) tfi v (twfType fromT) (getNme$ twfConstructor fromT) cp_lst
                        Nothing -> return unmake_decls
       return (data_decl++make_decl++from_funs)
  where mkCon (CP (_,cInf) e)
          = do let substIn :: FoundDecl (InpName, [Card]) v
                           -> Q (FoundDecl (QExp Information -> Exp) v)
                   substIn (FoundDecl (nm, _) tps)
                     = return (FoundDecl (\(QExp info) -> AppE (VarE (mkName (runUP nm))) info)
                                         tps)
               let (typUpd,_,constr) = typeByCard (cards e)
               e' <- upd onRAType runStatus <$> traverse substIn e
               return (typUpd (twfType (runStatus cInf)), CP (constr, runStatus cInf) e')


gen_from :: (Either (Info, Name) Name) -> ToFromInformation -> (Exp -> Exp) -> Type
         -> Name
         -> [Component (InpName, TBGTypeInfo)
                       TBGTypeInfo
                       (FoundDecl (InpName, [Card]) TBGTypeInfo)]
         -> Q [Dec]
gen_from (Left _) _ _ _ _ _ = error "done?!" -- return [] -- already generated, we are done (TODO: think about warning message?)
gen_from (Right from_name) infoT unmaker tp conNm cp_lst'
  = do arg <- newName (leadLower (reverse (fst (break (=='.') (reverse (pprint tp))))))
       let arInUnmade :: QExp Void
           arInUnmade = QExp (unmaker (VarE arg))
       toR <- newName "toR"
       let toRQE :: QExp ([Void] -> Relation Void Void)
           toRQE = QExp (VarE toR)
       cp_lst <- traverse (\o@(CP (nm,_) _) -> do {n <- newName (runUP nm); return (n,o)}) cp_lst'
       -- fromArticleIn :: ArticleIn -> Information
       let sigF = SigD from_name (arrowt tp (tfiType infoT))
       let getFD :: QExp [Void] -- variable name
                 -> FoundDecl InpName TBGTypeInfo
                 -> RAExpr tp (FoundDecl (UserProvided String, b) b1)
                 -> [QExp (Relation Void Void)]
           getFD _ _ (RAIdent _) = []
           getFD nm i (RAConverse e) = map (apQE converseQE) (getFD nm i e)
           getFD nm (FoundDecl nm1 _) (RAVar (FoundDecl (nm2,_) _))
             | runUP nm1 == runUP nm2 = [ apQE toRQE nm ]
             | otherwise = []
       let immediateSources
            = tfiConstruct infoT
               [ map runQExp $
                 concat [ getFD (cardfix (QExp (
                   (if (twfType tp'' /= twfType (target e)) then AppE (AppE (VarE 'fmap) (VarE (getNme (twfUnmakeStr tp'')))) else id)
                   (VarE v)))) fd e
                        | (v,CP (_, tp') e') <- cp_lst
                        , let e = upd onRAType runStatus e'
                        , let tp'' = runStatus tp'
                              (_,cardfix,_) = typeByCard (cards e)
                        ]
               | fd <- tfiRels infoT]
       let bodyM = foldl mappendQE immediateSources
                   $  -- add " <> foldMap fromNamedPerson aut"
                      [ let n = case twfFromStr tp'' of
                                  Left (_,n') -> n'
                                  Right n' -> n'
                        in QExp (AppE (AppE (VarE 'foldMap) (VarE n))
                                      (VarE v)) -- foldMap fromNamedPerson aut
                      | (v,CP (_, tp') e') <- cp_lst
                      , let tp'' = runStatus tp'
                      , let e = upd onRAType runStatus e'
                      , twfType tp'' /= twfType (target e)
                      ]
       -- toR = Relation . map ((,) (unmakeArticleIn a))
       let toRDB :: QExp ([b] -> Relation Void b)
           toRDB = composeQE relationQE (fmapQE (apQE pairQE (arInUnmade)))
       let toRD = FunD toR [Clause [] (NormalB (runQExp toRDB)) []]
       let decF = FunD from_name [Clause [AsP arg (ConP conNm (map (VarP . fst) cp_lst))] (NormalB (runQExp bodyM)) [toRD]]
       return [sigF, decF]
{-
fromArticleIn :: ArticleIn -> Information
fromArticleIn a@(ArticleIn aid ttl aut)
  = Information mempty (toR [aid]) (toR (map unmakeNamedPerson aut))
        mempty mempty mempty (toR [ttl]) <> foldMap fromNamedPerson aut
  where toR = Relation . map ((,) (unmakeArticleIn a))
fromNamedPerson :: NamedPerson -> Information
fromNamedPerson p@(NamedPerson uid nm)
  = Information (toR [uid]) mempty mempty mempty mempty (toR [nm]) mempty
  where toR = Relation . map ((,) (unmakeNamedPerson p))
fromReviewerIn :: ReviewerIn -> Information
fromReviewerIn r@(ReviewerIn uid nm opts)
  = Information (toR [uid]) mempty mempty (toR opts) mempty (toR [nm]) mempty
  where toR = Relation . map ((,) (unmakeReviewerIn r)) -}

-- unmakeNamedPerson :: NamedPerson -> Person
-- unmakeNamedPerson (NamedPerson u _) = Person u
gen_unmake
        :: Either (Info,Name) Name
        -> Type
        -> Name -- constructor name for in a pattern
        -> [Component
              (InpName, TBGTypeInfo)
              TBGTypeInfo
              (FoundDecl (InpName, [Card]) TBGTypeInfo)]
        -> Type
        -> (Either (Info,Name) Name) -- constructor name for in an expression
        -> [Component
              (InpName, TBGTypeInfo)
              TBGTypeInfo
              (FoundDecl (InpName, [Card]) TBGTypeInfo)]
        -> Q ([Dec], Maybe (Exp -> Exp))
gen_unmake unm tp1 constr1 cps1 tp2 constr2 cps2
 = do cps1' <- sequence [do v <- newName ("_x"++show i)
                            return (v,(e,tp)) | (i,CP (_, tp) e) <- zip [(0::Int)..] cps1]
      let varEquality
            :: FoundDecl (InpName, [Card]) TBGTypeInfo
            -> FoundDecl (InpName, [Card]) TBGTypeInfo -> Bool
          varEquality (FoundDecl (nm1,_) _tp1) (FoundDecl (nm2,_) _tp2)
            = (runUP nm1 == runUP nm2) -- types of declarations always match (TODO: this is by assumption about user input)
          findRel
            :: Component
                (InpName, TBGTypeInfo)
                TBGTypeInfo
                (FoundDecl (InpName, [Card]) TBGTypeInfo)
              -> Maybe Exp
          findRel (CP (_,tp) e)
            = listToMaybe [VarE v | (v,(e',tp')) <- cps1'
                                  , twfType (runStatus tp) ==
                                    twfType (runStatus tp')
                                  , eqExpr varEquality (\_ _ -> False) e e']
      case (unm,traverse findRel cps2, constr2) of
        (_,Just cps2',_)
          -> let constr2' = case constr2 of
                             Left (_,nm) -> nm
                             Right nm -> nm
                 bodyM = foldl AppE (ConE constr2') cps2' -- Person x1
                 tp1Pat = [ConP constr1 (map (VarP . fst) cps1')] -- (NamedPerson x1 x2)
                 lambdUM = LamE tp1Pat bodyM
             in (case unm of
                   (Left _) -> return ([], Just (AppE (lambdUM)))
                   (Right unmake_name)
                    -> return ( [ SigD unmake_name (arrowt tp1 tp2)
                                , FunD unmake_name [Clause tp1Pat (NormalB bodyM) []]
                                ]
                              , Just (AppE (VarE unmake_name))))
        (_,Nothing,Right constr2') -> runIO (putStrLn ("failed to make "++show constr2')) >> return ([],Nothing)
        _ -> return ([], Nothing) -- could not be generated or found

-- Check Cardinality
typeByCard :: Foldable t =>
    t Card -> (Type -> Type, QExp Void -> QExp [Void], QExp ([Void] -> Void))
typeByCard lst'
     | UNI `elem` lst' && TOT `elem` lst' =
          let head'' = (VarE 'head')
          in (id, \(QExp x) -> QExp (ListE [x]), QExp head'')
     | UNI `elem` lst' =
          let maybeT = (ConT ''Maybe)
              toList' = (VarE 'toList)
              listToMaybe' = (VarE 'listToMaybe)
          in (AppT maybeT, \(QExp x) -> QExp (AppE toList' x), QExp listToMaybe')
     | otherwise =
          let id' = VarE 'id
          in (AppT ListT, \(QExp x) -> QExp x, QExp id')

-- generates signatures and definitions for these functions:
-- makePaperInfo :: HasCallStack => Information -> Article -> PaperInfo
-- getPaperInfo :: HasCallStack => Information -> [PaperInfo]
obtain_make :: Name
            -> Name
            -> Type
            -> QExp (ListOf Void -> Void)
            -> TypeWhenFinishedInfo
            -> (Either (Type,a) (FilledInterface b))
            -> [Component (QExp ([Void] -> Void), TypeWhenFinishedInfo) TypeWhenFinishedInfo (FoundDecl (QExp Information -> Exp) TypeWhenFinishedInfo)]
            -> Q [Dec]
obtain_make makeTypeStr' getNm' infoT ifC ifT targetTp cp_lst
 = do let pure' = AppE $ VarE 'pure
      let sS' a b = InfixE (Just a) (VarE '(<*>)) (Just b)
      let converse' = AppE (VarE 'converse)
      let mkList' = InfixE Nothing (VarE '(:)) (Just (VarE '[]))
      let findIn' = AppE (VarE 'findIn)
      let dot' a b = InfixE (Just a) (VarE '(.)) (Just b)
      infoNm <- newName "info"
      let info = QExp (VarE infoNm) :: QExp Information
      let withInfo v = ForallT [] [ConT ''HasCallStack] (arrowt infoT v)
      -- makePaperInfo :: HasCallStack => Information -> Article -> PaperInfo
      let sigdeclMake
            = case targetTp of
                Left (tp,_) -> SigD makeTypeStr' (withInfo (arrowt tp (twfType ifT)))
                Right (Intf _ (v,_) _) -> SigD makeTypeStr' (withInfo (arrowt (twfType (runStatus v)) (twfType ifT)))
      -- translate an expression into the function to get it
      let translate :: RAExpr a (FoundDecl (QExp Information -> Exp) x) -> Exp
          translate (RAIdent _) = mkList'
          translate (RAVar (FoundDecl v _)) = v info
          translate (RAConverse t) = converse' (translate t)
      -- cp_proper is something like:
      -- pure ReviewerIn <*> head' . findIn (userId info)
      --                 <*> head' . findIn (name info)
      --                 <*> id . findIn (canreview info) -- each of these is the result of a 'properLookup'
      let properLookup :: Component
                         (QExp ([Void] -> Void), TypeWhenFinishedInfo) TypeWhenFinishedInfo
                         (FoundDecl (QExp Information -> Exp) TypeWhenFinishedInfo)
                       -> Q (QExp (Void -> Void))
          properLookup (CP (conv, cp_targetTp) expr)
             = do let e = findIn' (translate expr)
                  -- let makeTypeStrTgt = twfMakeStr cp_targetTp
                  -- makeTgt' <- lookupValueName makeTypeStrTgt
                  let makeTgt = VarE$ case twfMakeStr cp_targetTp of
                                        Right v -> v
                                        Left (_info,v) -> v -- todo: check type
                  let mkr = if (twfType (target expr) == twfType cp_targetTp)
                        then (\_ x -> x)
                        else (\(QExp inf) (QExp g) -> QExp (dot' (fmap' (AppE makeTgt inf)) g))
                  return (composeQE conv (mkr info (QExp e)))
      cp_proper <- mapM properLookup cp_lst
      let bodyMake = foldl (\b (QExp r) -> sS' b r) (pure' (runQExp ifC)) cp_proper
      let fundeclMake = FunD makeTypeStr' [Clause [VarP infoNm] (NormalB bodyMake) []]
      -- sigdeclGet looks something like:
      -- getPaperInfo :: HasCallStack => Information -> [PaperInfo]
      let sigdeclGet = SigD getNm' (withInfo (AppT ListT (twfType ifT)))
      -- mainListGet should look something like: (TODO)
      -- map fst . getRelation . title -- get unique list of [Paper] elements by using a relation which is UNI,TOT (or its converse if its INJ,SUR). If no such relation exists use the following:
      -- . nub . map fst . getRelation . title -- get unique list of [Paper] elements by using a relation which is TOT (or its converse if its SUR). If no such relation exists, use the following:
      -- concatenate all fields.
      -- TODO: concatenating all fields has a flaw: it omits producing empty constructors (i.e. one containing [] for every field).
      --       Instead of finding all elements in cp_lst, all elements of the 'Information' datatype should be searched!
      let mainListGet :: QExp [Void]
          mainListGet | null cp_lst = QExp (ListE [])
           -- | any [] -- don't have cardinality info here...
           | otherwise = foldr1 concatQE
                           [ apQE getSrcQE (QExp$ translate e)
                           | CP _ e <- cp_lst]
      let makeTypeStrQE :: QExp (Information -> Void -> Void)
          makeTypeStrQE = QExp (VarE makeTypeStr')
      let bodyGet = apQE (fmapQE (apQE makeTypeStrQE info))$
                    apQE nubQE mainListGet
      let fundeclGet = FunD getNm' [Clause [VarP infoNm] (NormalB (runQExp bodyGet)) []]
      return ([sigdeclMake,fundeclMake,sigdeclGet,fundeclGet])

converseQE :: QExp (Relation a b -> Relation b a)
converseQE = QExp (VarE 'converse)
relationQE :: QExp ([(a,b)] -> Relation a b)
relationQE = QExp (ConE 'Relation)
composeQE :: QExp (b -> a) -> QExp (c -> b) -> QExp (c -> a)
composeQE (QExp a) (QExp b) = QExp (InfixE (Just a) (VarE '(.)) (Just b))
concatQE :: QExp ([a]) -> QExp ([a]) -> QExp ([a])
concatQE (QExp a) (QExp b) = QExp (InfixE (Just a) (VarE '(++)) (Just b))
mappendQE :: Semigroup a => QExp a -> QExp a -> QExp a
mappendQE (QExp a) (QExp b) = QExp (InfixE (Just a) (VarE '(<>)) (Just b))
pairQE :: QExp (a -> b -> (a, b))
pairQE = QExp (ConE '(,))
getSrcQE :: QExp (Relation a b -> [a])
getSrcQE = QExp (InfixE (Just $ AppE (VarE 'map) (VarE 'fst))
              (VarE '(.)) (Just $ (VarE 'getRelation)))
              where _wantOneGetBoth = getTgtQE -- suppress defined but not used warning
getTgtQE :: QExp (Relation a b -> [b])
getTgtQE = QExp (InfixE (Just $ AppE (VarE 'map) (VarE 'snd))
              (VarE '(.)) (Just $ (VarE 'getRelation)))

nubQE :: QExp ([a] -> [a])
nubQE = QExp (VarE 'nub)

fmap' :: Exp -> Exp
fmap' = AppE $ VarE 'fmap -- inlined fmap' below to hopefully get an unused warning for fmap' at some point
fmapQE :: Functor f => QExp (a -> b) -> QExp (f a -> f b)
fmapQE (QExp a) = QExp $ (AppE $ VarE 'fmap) a

-- Generate Information
information_decl :: Map.Map String (TBGTypeInfo)
                 -> [Declaration] -> Q ([Dec], ToFromInformation)
information_decl lkpm declst =
  do let show' = ConT ''Show
         semigroup = ConT ''Semigroup
         monoid = ConT ''Monoid
         relationConstr = ConT ''Relation
         mon_append = '(<>)
         mempty' = 'mempty
     vars <- mapM (\i->(,) <$> newName ("x"++show i) <*> newName ("y"++show i))
                  [1..length declst]
     let
       infoNM = mkName "Information" -- TODO: check if this exists, and allow it to be customized
       construct = foldl AppE (ConE infoNM) -- construct an 'Information', needs a list of Exp arguments.
       appVars :: [Exp] -- [x0 <> x1,y0 <> y1]
       appVars = map (\(x,y)->(AppE (AppE (VarE mon_append) (VarE x)) (VarE y))) vars
       rls = RecC infoNM (map (gen_data_relation lkpm relationConstr) declst)
       drv = DerivClause Nothing [show']
       concat' :: [Exp] -> Exp
       concat' [] = VarE mempty'
       concat' [v] = v
       concat' lst = foldr1 (\ a b -> AppE (AppE (VarE mon_append) a) b) lst
     return ( [ DataD [] infoNM [] Nothing [rls] [drv] -- data Information = ...
              , InstanceD Nothing [] (AppT semigroup (ConT infoNM)) -- instance Semigroup Information where
                 [ FunD mon_append -- Information x0 x1 <> Information y0 y1
                    [Clause [ConP infoNM (map (VarP . fst) vars)
                            ,ConP infoNM (map (VarP . snd) vars) ]
                            -- = Information (x0 <> x1) (y0 <> y1)
                            (NormalB (construct appVars)) []
                    ]
                 ]
              , InstanceD Nothing [] (AppT monoid (ConT infoNM)) -- instance Monoid Information where
                 -- mempty = Information mempty mempty
                 [ FunD mempty' [Clause [] (NormalB (construct (map (\_ -> VarE mempty') vars))) []]]
              ]
            , TFI{ tfiType = ConT infoNM -- the type 'Information'
                 , tfiConstruct = QExp . construct . map concat'
                 , tfiRels = map (\(Decl a (RelationType t1 t2) _)
                                     -> FoundDecl a (lkpm Map.! (runUP t1),lkpm Map.! (runUP t2))) declst
                 }
            )

-- Generate Relations in Information

gen_data_relation :: Map.Map String TBGTypeInfo
                  -> Type -> Declaration -> (Name, Bang, Type)
gen_data_relation lkp relC (Decl dnm (RelationType rnm1 rnm2) _) =
  let
    nm1 = twfType (runStatus (lkp Map.! (runUP rnm1)))
    nm2 = twfType (runStatus (lkp Map.! (runUP rnm2)))
    rlNM = mkName (runUP dnm) -- TODO: check if this exists, and allow it to be customized
    ba = Bang NoSourceUnpackedness NoSourceStrictness
  in (rlNM, ba, AppT (AppT relC nm1) nm2)

{-
Convert first letter in string to lower case
-}
leadLower :: String -> String
leadLower (a:as) = toLower a : as
leadLower [] = []
