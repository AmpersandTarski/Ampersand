CONTEXT Deliveries

SERVICE Customer : I[Client]
 = [ Order : from[Order*Client]~
      = [ Store: addressedTo
        , Items : item
        , bestelnummer: accepted~;accepted /\ I  -- alleen de geaccepteerde orders
        , besteldatum: date
        ]
   , Delivery: deliveredTo~
      = [ order: of
        , store: of;addressedTo
        , delivered: of;addressedTo;provided /\ I
        , Items : item
        , bezorgdatum: date
        ]
   , invoice : sentTo~
      = [ invoiceNr: I[Invoice]
        , paid : paid~
        , Order: from
        , Store: from;addressedTo~
        , factuurdatum: date
        ]

   ]

SERVICE Provider : I[Provider]
 = [ Order : addressedTo~
      = [ ordernumber: I[Order]
        , from : from
        , Items : item
        , accepted: accepted~;addressedTo~ /\ I
        , besteldatum: date
        ]
   , accepted : accepted
   , Delivery: provided
      = [ DeliveryNr: I[Delivery]
        , provider: provided~
        , order: of
        , client: deliveredTo
        , Items : item
        , bezorgdatum: date
        ]
   , Invoice : from~
      = [ invoiceNr: I[Invoice]
        , delivery : delivery
        , paid : paid~
        , klant : sentTo
        , Store: from;addressedTo~
        , factuurdatum: date
        ]
   ]

SERVICE Bestellingen : I[Order]
 = [ van : from
   , aan : addressedTo
  -- , betaaldeOrders : from;paid;delivery;of;V[Order*ONE]
   , datum: date
   ]

SERVICE Rekeningen : I[Invoice]
 = [ leverancier : from
   , leverantie : delivery
   , klant : sentTo
   , betaaldeOrders : paid~;paid
   , datum: date
   ]

SERVICE Levering : I[Delivery]
 = [ leverancier : provided~
   , Order : of
   , klant : deliveredTo
   , datum: date
  -- , betaald : deliveredTo;paid;delivery;V[Delivery*ONE]
   ]

SERVICE Orderitem : I[Product]
 = [ klant : item[Order*Product]~;from
   , leverancier : item[Delivery*Product]~;provided~
   ]


SERVICE Bestellijst : I[ONE]
 = [ LijstItem : V[ONE*Delivery]
      = [ leverancier : provided~	
        , klant : deliveredTo
       -- , betaald : deliveredTo;paid;delivery;V[Delivery*ONE]
        , bezorgdatum: date
   ]    ]

PATTERN Deliveries

 item :: Order * Product
  = [ ("C45666"                  , "Jelly beans"  )
    ; ("Order 22/09/2006 Cookies", "Cookies"      )
    ; ("C45683"                  , "Peanut butter")
    ].
 date :: Order -> Date
  = [ ("C45666"                  , "2010-01-11")
    ; ("Order 22/09/2006 Cookies", "2010-04-11")
    ; ("C45683"                  , "2010-10-23")
    ].
 item :: Delivery * Product
  = [ ("Jelly beans #4921"  , "Jelly beans"  )
    ; ("Cookies #0382"      , "Cookies"      )
    ; ("Peanut butter #1993", "Peanut butter")
    ].
 date :: Delivery -> Date
  = [ ("Jelly beans #4921"  , "2010-01-12")
    ; ("Cookies #0382"      , "2010-04-12")
    ; ("Peanut butter #1993", "2010-10-24")
    ].

-- Er mag tijdelijk een order zijn zonder delivery. dus moet de surjectiviteit van 'of' worden gesignaleerd....

SIGNAL deliver ON I |- of~;of EXPLANATION "De volgende order zit in de pijplijn"

 of :: Delivery -> Order
  = [ ("Cookies #0382"      , "Order 22/09/2006 Cookies")
    ; ("Jelly beans #4921"  , "C45666"                  )
    ; ("Peanut butter #1993", "C45683"                  )
    ].
 item[Delivery*Product] |- of;item
  EXPLANATION "There must be an order for every item delivered."
 of;item |- item[Delivery*Product]
  EXPLANATION "All items ordered must be delivered."
 provided :: Provider * Delivery [SUR,INJ] PRAGMA "Provider " " has delivered delivery "
  = [ ("Candy's candy", "Cookies #0382")
    ; ("Carter"       , "Jelly beans #4921")
    ; ("Carter"       , "Peanut butter #1993")
    ].

-- Er mag tijdelijk een order zijn die nog niet is geaccepteerd. dus moet de surjectiviteit van 'accepted' worden gesignaleerd....
SIGNAL accepteren ON I |- accepted~;accepted EXPLANATION "De volgende order(s) is/zijn nog niet geaccepteerd."

 accepted :: Provider * Order [INJ] PRAGMA "Provider " " has accepted order "
  = [ ("Candy's candy", "Order 22/09/2006 Cookies")
    ; ("Carter"       , "C45666"                  )
    ; ("Carter"       , "C45683"                  )
    ].

-- \ref{rule 0}	Accepting an order is always done by the provider to whom the order was addressed.
 accepted |- addressedTo~ -- \ref{rule 0} % uit het artikel
 EXPLANATION "not allowed to accept this order"

-- \ref{rule 1}	Orders that are awaiting acceptance are signalled to the provider to whom the order was addressed.
SIGNAL order ON addressedTo~ |- accepted  -- \ref{rule 1} % uit het artikel
 EXPLANATION "orders received."

-- \ref{rule 2}
--	Deliveries are made by the provider who has accepted an order.
 accepted;of~ |- provided
  EXPLANATION "If a provider has accepted an order, then that provider is the one to make the delivery"

{- Something funny:
      accepted;of~ |- provided
 =>     { monotony }
      accepted;of~;of |- provided;of
 =>     { I |- of~;of  ('of' is surjective) }
      accepted |- provided;of
The funny thing is: if   <RULE accepted;of~ |- provided\>   is always satisfied, then so is <RULE accepted |- provided;of\>.
However, The signal <SIGNAL deliver\>, which signals violation of the latter, is being raised during the demo.
So <RULE accepted |- provided;of\> can be violated.
So <RULE accepted;of~ |- provided\> is not always satisfied.
So COMPUTING does not keep a rule satisfied at all times.
-}
-- provided |- accepted;of~  -- Since of is a function, this is equivalent to provided;of |- accepted
--  EXPLANATION "No delivery is made to a client without an order accepted by the producer. (1.38)"

-- \ref{rule 3}
--	Ultimately, each order accepted must be delivered by the provider who has accepted that order.
--	The provider will be signalled of orders waiting to be delivered.
 SIGNAL deliver ON accepted |- provided;of
  EXPLANATION "deliverable orders"

 addressedTo :: Order -> Provider PRAGMA "Order " " was issued to provider "
  = [ ("Order 22/09/2006 Cookies", "Candy's candy")
    ; ("C45666"                  , "Carter"       )
    ; ("C45683"                  , "Carter"       )
    ].

 deliveredTo :: Delivery -> Client
  = [ ("Jelly beans #4921",	"Applegate")
    ; ("Cookies #0382",	"Brown")
    ; ("Peanut butter #1993",	"Conway")
    ].
 from :: Order -> Client
  = [ ("C45666"                  , "Applegate")
    ; ("Order 22/09/2006 Cookies", "Brown"    )
    ; ("C45683"                  , "Conway"   )
    ].

-- \ref{rule 4}	Deliveries are made to the client who ordered the delivery
 of;from |- deliveredTo
  EXPLANATION "Deliveries are made to the client who ordered the delivery."
 date |- of;date;onafter
  EXPLANATION "The date of a delivery must be on or after the date of the order"

 sentTo :: Invoice -> Client PRAGMA "Invoice " " was sent to "
  = [ ("5362a", "Applegate")
    ; ("721i" , "Brown"    )
    ; ("9443a", "Conway"   )
    ].

-- Er mag tijdelijk een leverantie zijn zonder rekening. dus moet de surjectiviteit van 'delivery' worden gesignaleerd....
SIGNAL factureren ON I |- delivery~;delivery EXPLANATION "De volgende leverantie(s) is/zijn nog niet gefactureerd."

 delivery :: Invoice -> Delivery PRAGMA "Invoice " " covers delivery "
  = [ ("5362a", "Jelly beans #4921")
    ; ("721i" , "Cookies #0382"    )
    ; ("9443a", "Peanut butter #1993"   )
    ].

-- \ref{rule 5}	A client accepts invoices for delivered orders only
 delivery~;sentTo |- deliveredTo
  EXPLANATION "A client accepts invoices for delivered orders only. (1.39)"

 from :: Invoice -> Provider PRAGMA "Invoice " " has been sent by "
  = [ ("721i" , "Candy's candy")
    ; ("5362a", "Carter"       )
    ; ("9443a", "Carter"       )
    ].

 date :: Invoice -> Date PRAGMA "Invoice " " has been or will be sent at "
  = [ ("721i" , "2011-01-03")
    ; ("5362a", "2011-01-03")
    ; ("9443a", "2011-01-03")
    ]. 
       
-- from = delivery;provided~
--  EXPLANATION "There must be a delivery for every invoice sent."
 date |- delivery;date;onafter
  EXPLANATION "The date of an invoice must be on or after its delivery"

SIGNAL pending ON provided = from~;delivery
 EXPLANATION "invoices to be sent (1.40)"

-- Er mag tijdelijk een onbetaalde rekening zijn, maar dat moet worden gesignaleerd.
-- Dus moet de surjectiviteit van 'paid' worden gesignaleerd....
SIGNAL teBetalen ON I |- paid~;paid EXPLANATION "De volgende factu(u)r(en) is/zijn nog niet betaald."

 paid :: Client * Invoice [INJ] PRAGMA "Client " " has paid invoice "
  = [ ("Applegate", "5362a")
    ; ("Brown", "721i")
    ; ("Conway", "9443a")
    ].
 paid |- sentTo~ EXPLANATION "Accept payments only for invoices sent"
 SIGNAL payable ON sentTo~ |- paid
 EXPLANATION "Invoices to be paid"
 --sentTo = delivery;of;from
ENDPATTERN

PATTERN Date -- provides onafter[Date*Date] and I[Date]
 CONCEPT Date "Een datum (dag in het jaar)"
 onafter :: Date * Date PRAGMA "The day " " is on or after the day " " (the former comes later in time)"
  = [ ("2010-10-24", "2011-01-03" );("2010-01-12", "2011-01-03");("2010-04-12", "2011-01-03")
    ; ("2010-10-23", "2010-10-24" );("2010-01-11", "2010-01-12");("2010-04-11", "2010-04-12")].
ENDPATTERN
ENDCONTEXT
