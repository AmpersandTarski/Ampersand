{-# LANGUAGE OverloadedStrings #-}
module Ampersand.Output.FSpec2Solidity (fSpec2Solidity)
where
import           Ampersand.Basics
import           Ampersand.Classes
import           Ampersand.Core.AbstractSyntaxTree
import           Ampersand.Core.ShowAStruct
import           Ampersand.FSpec
import           Ampersand.FSpec.Transformers
import qualified Data.List as List
import qualified Data.Set as Set
import qualified Data.Text as Text

fSpec2Solidity :: MultiFSpecs -> Text.Text
fSpec2Solidity multi =
  Text.intercalate "\n" $
         ["/*"
         ,"This file is generated using " <> (Text.pack ampersandVersionStr)
         ,"*/"
         ,""
         ,"pragma solidity ^0.5.1;"
         ,""
         ,""
         ,"import \"./Seriality.sol\";"
         ,""
         ,"         contract Concept {"
         ,"  bytes32 public name; // name of the concept"
         ,"  bytes32[] public ids; // id's of all the atoms in the concept"
         ,"  constructor(bytes32 _name, bytes32[] memory _ids) public {"
         ,"    name = _name;"
         ,"    ids = _ids;"
         ,"  }"
         ,"  function setName (bytes32 a) public payable {"
         ,"    name = a;"
         ,"  }"
         ,"  function getIds() public view returns (bytes32[] memory) {"
         ,"    return ids;"
         ,"  }"
         ,"  function setIds(bytes32[] memory a) public payable {"
         ,"    ids = a;"
         ,"  }"
         ,"  function addId(bytes32 _id) public payable {"
         ,"    ids.push(_id);"
         ,"  }"
         ,"  function removeId(bytes32 _id) public payable {"
         ,"    uint itemsRemoved = 0;"
         ,"    // first remove all occurrences of id (should occur only once)"
         ,"    for (uint i = 0; i < ids.length; i++){"
         ,"      if (ids[i] == _id) {"
         ,"        delete(ids[i]);"
         ,"        ++itemsRemoved;"
         ,"      } else if (itemsRemoved > 0) {"
         ,"        ids[i - itemsRemoved] = ids[i];"
         ,"      }"
         ,"    }"
         ,"    if (itemsRemoved == 1) {"
         ,"      // if an item was removed, shrink the ids array by one"
         ,"      delete(ids[ids.length - 1]);"
         ,"      --ids.length;"
         ,"    } else if (itemsRemoved > 0) {"
         ,"      emit Error(\"Person ids should have been unique!\");"
         ,"    }"
         ,"  }"
         ,"  //Events"
         ,"  event Error(string _errorMessage);"
         ,"}"
         ,""
         ,"contract Relation {"
         ,"  bytes32 public name;"
         ,"  bool public univalent;"
         ,"  bool public total;"
         ,"  bool public surjective;"
         ,"  bool public injective;"
         ,"  bool public reflexive;"
         ,"  bool public irreflexive;"
         ,"  bool public transitive;"
         ,"  bool public symmetric;"
         ,"  bool public asymmetric;"
         ,"  bool public property;"
         ,"  Concept public source;"
         ,"  Concept public target;"
         ,"  bool public flipped;"
         ,"  mapping (bytes32 => bytes32[]) public relationMap;"
         ,"  mapping (bytes32 => bytes32[]) public relationMapFlip;"
         ,"  constructor(bytes32 _name, bool _univalent, bool _total, bool _surjective,"
         ,"    bool _injective, bool _reflexive, bool _irreflexive, bool _transitive,"
         ,"    bool _symmetric, bool _asymmetric, bool _property, Concept _source, Concept _target, bool _flipped) public {"
         ,"    name = _name;"
         ,"    univalent = _univalent;"
         ,"    total = _total;"
         ,"    surjective = _surjective;"
         ,"    injective = _injective;"
         ,"    reflexive = _reflexive;"
         ,"    irreflexive = _irreflexive;"
         ,"    transitive = _transitive;"
         ,"    symmetric = _symmetric;"
         ,"    asymmetric = _asymmetric;"
         ,"    property = _property;"
         ,"    source = _source;"
         ,"    target = _target;"
         ,"    flipped = _flipped;"
         ,"  }"
         ,""
         ,"  function setName(bytes32 a) public payable{"
         ,"    name = a;"
         ,"  }"
         ,"  function setUnivalent(bool a) public payable{"
         ,"    setUnivalent(a);"
         ,"  }"
         ,"  function setTotal(bool a) public payable{"
         ,"    setTotal(a);"
         ,"  }"
         ,"  function setSurjective(bool a) public payable{"
         ,"    setSurjective(a);"
         ,"  }"
         ,"  function setInjective(bool a) public payable{"
         ,"    setInjective(a);"
         ,"  }"
         ,"  function setReflexive(bool a) public payable{"
         ,"    reflexive = a;"
         ,"  }"
         ,"  function setIrreflexive(bool a) public payable{"
         ,"    setReflexive(a);"
         ,"  }"
         ,"  function setTransitive(bool a) public payable{"
         ,"    transitive= a;"
         ,"  }"
         ,"  function setSymmetric(bool a) public payable{"
         ,"    setSymmetric(a);"
         ,"  }"
         ,"  function setAsymmetric(bool a) public payable{"
         ,"    asymmetric= a;"
         ,"  }"
         ,"  function setIsProperty(bool a) public payable{"
         ,"    setIsProperty(a);"
         ,"  }"
         ,"  function setSource(Concept a) public payable{"
         ,"    source = a;"
         ,"  }"
         ,"  function setTarget(Concept a) public payable{"
         ,"    target = a;"
         ,"  }"
         ,"  function setFlipped(bool a) public payable{"
         ,"    setFlipped(a);"
         ,"  }"
         ,"  function addPairToMap(bytes32 a, bytes32 b) public payable{"
         ,"    if (flipped) {"
         ,"      relationMap[b].push(a);"
         ,"      relationMapFlip[a].push(b);"
         ,"    } else {"
         ,"      relationMap[a].push(b);"
         ,"      relationMapFlip[b].push(a);"
         ,"    }"
         ,""
         ,"  }"
         ,"  function getRelationMapSourceAtoms() public view returns (bytes32[] memory) {"
         ,"    bytes32[] memory allSource = source.getIds();"
         ,"    bytes32[] memory usedSource = new bytes32[](allSource.length);"
         ,"    for (uint idx = 0; idx < allSource.length; ++idx) {"
         ,"      if (relationMap[allSource[idx]].length > 0) {"
         ,"        usedSource[idx] = allSource[idx];"
         ,"      }"
         ,"    }"
         ,"    return usedSource;"
         ,"  }"
         ,"  function nrOfTargetsForSource(bytes32 sourceArg) public view returns (uint256) {"
         ,"    return relationMap[sourceArg].length;"
         ,"  }"
         ,"  function getTargetsForSource(bytes32 sourceArg) public view returns (bytes32[] memory) {"
         ,"    return relationMap[sourceArg];"
         ,"  }"
         ,""
         ,"  function getRelationMapFlipSourceAtoms() public view returns (bytes32[] memory) {"
         ,"    bytes32[] memory allSource = target.getIds();"
         ,"    bytes32[] memory usedSource = new bytes32[](allSource.length);"
         ,"    for (uint idx = 0; idx < allSource.length; ++idx) {"
         ,"      if (relationMapFlip[allSource[idx]].length > 0) {"
         ,"        usedSource[idx] = allSource[idx];"
         ,"      }"
         ,"    }"
         ,"    return usedSource;"
         ,"  }"
         ,"  function nrOfSourcesForTarget(bytes32 targetArg) public view returns (uint256) {"
         ,"    return relationMapFlip[targetArg].length;"
         ,"  }"
         ,"  function getSourcesForTarget(bytes32 targetArg) public view returns (bytes32[] memory) {"
         ,"    return relationMapFlip[targetArg];"
         ,"  }"
         ,""
         ,"  //Events"
         ,"  event Error(string _errorMessage);"
         ,"  // function getRelationMapTargets() public returns (bytes32[][] memory usedTargets) {"
         ,"  //   bytes32[] allSource = target.getIds();"
         ,"  //   bytes32[] usedSource;"
         ,"  //   for (uint idx = 0; idx < allSource.length; ++idx) {"
         ,"  //     if (relationMapFlip[allSource[idx]].length > 0) {"
         ,"  //       usedSource.push(allSource[idx]);"
         ,"  //     }"
         ,"  //   }"
         ,"  // }"
         ,"  // function getRelationMapFlipTargets() public returns (bytes32[][] memory usedTargets) {"
         ,""
         ,"  // }"
         ,"}"
         ,""
         ,"contract " <> (Text.pack $ show . originalContext $ fSpec) <> " {"
         ,""
         ,"/* ******************************************** Standard structs and functions present in every contract ********************************************** */"
         ,""
         ,"function bytes32ToString(bytes32 x) internal pure returns (string memory) {"
         ,"  bytes memory bytesString = new bytes(32);"
         ,"  uint charCount = 0;"
         ,"  for (uint j = 0; j < 32; j++) {"
         ,"    byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));"
         ,"    if (char != 0) {"
         ,"      bytesString[charCount] = char;"
         ,"      charCount++;"
         ,"    }"
         ,"  }"
         ,"  bytes memory bytesStringTrimmed = new bytes(charCount);"
         ,"  for (uint j = 0; j < charCount; j++) {"
         ,"    bytesStringTrimmed[j] = bytesString[j];"
         ,"  }"
         ,"  return string(bytesStringTrimmed);"
         ,"}"
         ,""
         ,"function findInArray(bytes32[] memory array, bytes32 element) internal pure returns (int) {"
         ,"  for (uint i = 0; i < array.length; ++i) {"
         ,"    if (array[i] == element) {"
         ,"      return int(i);"
         ,"    }"
         ,"  }"
         ,"  return -1;"
         ,"}"
         ,""
         ,"function copyRelation(Relation srcRel, Relation tgtRel) internal {"
         ,"  tgtRel.setName(srcRel.name());"
         ,"  tgtRel.setUnivalent(srcRel.univalent());"
         ,"  tgtRel.setTotal(srcRel.total());"
         ,"  tgtRel.setSurjective(srcRel.surjective());"
         ,"  tgtRel.setInjective(srcRel.injective());"
         ,"  tgtRel.setReflexive(srcRel.reflexive());"
         ,"  tgtRel.setIrreflexive(srcRel.irreflexive());"
         ,"  tgtRel.setTransitive(srcRel.transitive());"
         ,"  tgtRel.setSymmetric(srcRel.symmetric());"
         ,"  tgtRel.setAsymmetric(srcRel.asymmetric());"
         ,"  tgtRel.setIsProperty(srcRel.property());"
         ,"  tgtRel.setSource(srcRel.source());"
         ,"  tgtRel.setTarget(srcRel.target());"
         ,"  tgtRel.setFlipped(srcRel.flipped());"
         ,"  // It would be nice if we could do the following:"
         ,"  // tgtRel.relationMap = srcRel.relationMap;"
         ,"  // tgtRel.relationMapFlip = srcRel.relationMapFlip;"
         ,"  // However, we need to copy the mapping manually, no reference is possible."
         ,"  bytes32[] memory sourceAtoms = srcRel.source().getIds();"
         ,"  for(uint idx = 0; idx < sourceAtoms.length; ++idx) {"
         ,"    uint numTargets = srcRel.nrOfTargetsForSource(sourceAtoms[idx]);"
         ,"    // bytes32[numTargets] memory targetAtoms = srcRel.relationMap(sourceAtoms[idx]);"
         ,"    for (uint jdx = 0; jdx < numTargets; ++jdx) {"
         ,"      tgtRel.addPairToMap(sourceAtoms[idx], srcRel.relationMap(sourceAtoms[idx], jdx));"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// verifies that a and b have the same source and target concepts"
         ,"function assertSameTypes(Relation a, Relation b) internal {"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  if (flipA == flipB) {"
         ,"    if (a.source().name() != b.source().name() || a.target().name() != b.target().name()) {"
         ,"      emit Error(\"Error: incompatible types.\");"
         ,"    }"
         ,"  } else { // flipA != flipB, only one is flipped"
         ,"    if (a.source().name() != b.target().name() || a.target().name() != b.source().name()) {"
         ,"      emit Error(\"Error: incompatible types.\");"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// verifies that a's target is b's source concept"
         ,"function assertTgtAIsSrcB(Relation a, Relation b) internal {"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  if (flipA){"
         ,"    if (flipB){"
         ,"      if (keccak256(abi.encode(a.source())) != keccak256(abi.encode(b.target()))) {"
         ,"        emit Error(\"Error: incompatible types, a.source() should be b.target().\");"
         ,"      }"
         ,"    } else {"
         ,"      if (keccak256(abi.encode(a.source())) != keccak256(abi.encode(b.source()))) {"
         ,"        emit Error(\"Error: incompatible types, a.source() should be b.source().\");"
         ,"      }"
         ,"    }"
         ,"  } else {"
         ,"    if (flipB) {"
         ,"      if (keccak256(abi.encode(a.target())) != keccak256(abi.encode(b.target()))) {"
         ,"        emit Error(\"Error: incompatible types, a.target() should be b.target().\");"
         ,"      }"
         ,"    } else {"
         ,"      if (keccak256(abi.encode(a.target())) != keccak256(abi.encode(b.source()))) {"
         ,"        emit Error(\"Error: incompatible types, a.target() should be b.source().\");"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// Return the identity relation, with all atoms mapped only to themselves."
         ,"function identity(Concept a) internal returns (Relation) {"
         ,"  Relation identityRelation;"
         ,"  identityRelation.setName(\"identityPerson\");"
         ,"  identityRelation.setUnivalent(true);"
         ,"  identityRelation.setTotal(true);"
         ,"  identityRelation.setSurjective(true);"
         ,"  identityRelation.setInjective(true);"
         ,"  identityRelation.setIsProperty(false);"
         ,"  identityRelation.setReflexive(false);"
         ,"  identityRelation.setSymmetric(false);"
         ,"  identityRelation.setFlipped(false);"
         ,"  identityRelation.setSource(a);"
         ,"  identityRelation.setTarget(a);"
         ,"  "
         ,"  bytes32[] memory sourceAtoms = a.getIds();"
         ,""
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    identityRelation.addPairToMap(sourceAtoms[i], sourceAtoms[i]); // relationMap[sourceAtoms[i]].push(sourceAtoms[i]);"
         ,"  }"
         ,"  return identityRelation;"
         ,"}"
         ,""
         ,"function equivalence(Relation a, Relation b) internal view returns (bool) {"
         ,"  // Compare only pairs in the relation to determine equivalence."
         ,"  // Since the relationMap and relationMapFlip members are symmetric, we only evaluate one of them."
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  // var mappingA = flipA ? a.getRelationMapFlip() : a.getRelationMap();"
         ,"  // var mappingB = flipB ? b.getRelationMapFlip() : b.getRelationMap();"
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds();"
         ,"  for (uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[i]) : b.getTargetsForSource(allSourceAtoms[i]);"
         ,"    if (targetAtomsA.length != targetAtomsB.length) {"
         ,"      return false;"
         ,"    }"
         ,"    bool alsoInB = false;"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          alsoInB = true;"
         ,"        }"
         ,"      }"
         ,"      if (!alsoInB) {"
         ,"        return false;"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return true;"
         ,"}"
         ,""
         ,"// Returns true if all pairs of atoms in relation a are also present in relation b, i.e. a is a subset of b."
         ,"function inclusion(Relation a, Relation b) internal returns(bool){"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  assertSameTypes(a, b);"
         ,"  // var mappingA = flipA ? a.getRelationMapFlip() : a.getRelationMap();"
         ,"  // var mappingB = flipB ? b.getRelationMapFlip() : b.getRelationMap();"
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds();"
         ,"  for(uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[i]) : b.getTargetsForSource(allSourceAtoms[i]);"
         ,"    // in a, some targets are reached from the current source atom."
         ,"    // we now check if all source-target pairs are also present in b."
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      bool matched = false;"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          matched = true;"
         ,"          return false;"
         ,"          continue;"
         ,"        }"
         ,"      }"
         ,"      if (!matched) {"
         ,"        return false;"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return true;"
         ,"}"
         ,""
         ,"function intersection(Relation a, Relation b) internal returns (Relation) {"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  assertSameTypes(a, b);"
         ,"  "
         ,"  Relation intersectionRelation;"
         ,"  intersectionRelation.setName(\"identityPerson\");"
         ,"  intersectionRelation.setUnivalent(false);"
         ,"  intersectionRelation.setTotal(false);"
         ,"  intersectionRelation.setSurjective(false);"
         ,"  intersectionRelation.setInjective(false);"
         ,"  intersectionRelation.setIsProperty(false);"
         ,"  intersectionRelation.setReflexive(false);"
         ,"  intersectionRelation.setSymmetric(false);"
         ,"  intersectionRelation.setFlipped(false);"
         ,"  intersectionRelation.setSource(flipA ? a.target() : a.source());"
         ,"  intersectionRelation.setTarget(flipA ? a.source() : a.target());"
         ,"  "
         ,""
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds();"
         ,""
         ,"    // find all source-target pairs that are present in both a and b."
         ,"  for(uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[i]) : b.getTargetsForSource(allSourceAtoms[i]);"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          intersectionRelation.addPairToMap(allSourceAtoms[i], targetAtomsA[j]);"
         ,"        }"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return intersectionRelation;"
         ,"}"
         ,""
         ,"function union(Relation a, Relation b) internal returns (Relation) {"
         ,"  assertSameTypes(a, b);"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  Relation unionRelation;"
         ,"  unionRelation.setName(\"unionRelation\");"
         ,"  unionRelation.setUnivalent(false);"
         ,"  unionRelation.setTotal(false);"
         ,"  unionRelation.setSurjective(false);"
         ,"  unionRelation.setInjective(false);"
         ,"  unionRelation.setIsProperty(false);"
         ,"  unionRelation.setReflexive(false);"
         ,"  unionRelation.setSymmetric(false);"
         ,"  unionRelation.setFlipped(false);"
         ,"  unionRelation.setSource(flipA ? a.target() : a.source());"
         ,"  unionRelation.setTarget(flipA ? a.source() : a.target());"
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds();"
         ,"  // add all pairs that are present in a, but not b."
         ,"  for (uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32 sourceAtom = allSourceAtoms[i];"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[i]) : b.getTargetsForSource(allSourceAtoms[i]);"
         ,"    for (uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      unionRelation.addPairToMap(sourceAtom, targetAtomsA[j]);"
         ,"    }"
         ,""
         ,"    for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"      bytes32 targetAtomB = targetAtomsB[k];"
         ,"      bool wasInA = false;"
         ,"      for (uint l = 0; l < targetAtomsA.length; ++l) {"
         ,"        if (targetAtomB == targetAtomsA[l]) {"
         ,"          wasInA = true;"
         ,"          break;"
         ,"        }"
         ,"      }"
         ,"      if (!wasInA) {"
         ,"        unionRelation.addPairToMap(sourceAtom, targetAtomB);"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return unionRelation;"
         ,"}"
         ,""
         ,"// Returns a new relation with all pairs in a that are not in b."
         ,"function difference(Relation a, Relation b) internal returns (Relation) {"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  assertSameTypes(a, b);"
         ,""
         ,"  Relation differenceRelation;"
         ,"  differenceRelation.setName(\"differenceRelation\");"
         ,"  differenceRelation.setUnivalent(false);"
         ,"  differenceRelation.setTotal(false);"
         ,"  differenceRelation.setSurjective(false);"
         ,"  differenceRelation.setInjective(false);"
         ,"  differenceRelation.setIsProperty(false);"
         ,"  differenceRelation.setReflexive(false);"
         ,"  differenceRelation.setSymmetric(false);"
         ,"  differenceRelation.setFlipped(false);"
         ,"  differenceRelation.setSource(flipA ? a.target() : a.source());"
         ,"  differenceRelation.setTarget(flipA ? a.source() : a.target());"
         ,""
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds();"
         ,"  // find all pairs that are present in a, but not b."
         ,"  for(uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[i]) : b.getTargetsForSource(allSourceAtoms[i]);"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      bool alsoInB = false;"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          alsoInB = true;"
         ,"          break;"
         ,"        }"
         ,"      }"
         ,"      if (!alsoInB) {"
         ,"        differenceRelation.addPairToMap(allSourceAtoms[i], targetAtomsA[j]);"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return differenceRelation;"
         ,"}"
         ,""
         ,"function diamond(Relation a, Relation b) internal returns (Relation) {"
         ,"  assertTgtAIsSrcB(a, b);"
         ,"  Relation diamondRelation;"
         ,"  diamondRelation.setName(\"diamondRelation\");"
         ,"  diamondRelation.setUnivalent(false);"
         ,"  diamondRelation.setTotal(false);"
         ,"  diamondRelation.setSurjective(false);"
         ,"  diamondRelation.setInjective(false);"
         ,"  diamondRelation.setIsProperty(false);"
         ,"  diamondRelation.setReflexive(false);"
         ,"  diamondRelation.setSymmetric(false);"
         ,"  diamondRelation.setFlipped(false);"
         ,"  diamondRelation.setSource(a.flipped() ? a.target() : a.source());"
         ,"  diamondRelation.setTarget(b.flipped() ? b.source() : b.target());"
         ,"  // var allBetween = a.flipped ? a.source().getIds() : a.target.getIds();"
         ,"  bytes32[] memory allSourceA = a.flipped() ? a.target().getIds() : a.source().getIds();"
         ,"  // bytes32[] allTargetA = a.flipped ? a.source().getIds() : a.target().getIds();"
         ,"  // bytes32[] allSourceB = b.flipped ? b.target().getIds() : b.source().getIds();"
         ,"  bytes32[] memory allTargetB = b.flipped() ? b.source().getIds() : b.target().getIds();"
         ,"  for (uint i = 0; i < allSourceA.length; ++i) {"
         ,"    bytes32 p = allSourceA[i];"
         ,"    // add [p, q] for all atoms q in allTargetB such either"
         ,"    //   a.  (p,x) in a's relation map and (x,q) in b's relation map."
         ,"    //   b.  both NOT in the relationship maps"
         ,"    // for all x."
         ,"    bytes32[] memory xA = a.flipped() ? a.getSourcesForTarget(p) : a.getTargetsForSource(p); // array of everything reached from p"
         ,"    for (uint j = 0; j < allTargetB.length; ++j) {"
         ,"      bytes32 q = allTargetB[j];"
         ,"      bytes32[] memory xB = b.flipped() ? b.getTargetsForSource(q) : b.getSourcesForTarget(q);"
         ,"      // check if xA and xB contain exactly the same atoms"
         ,"      if (xA.length != xB.length) {"
         ,"        continue;"
         ,"      }"
         ,"      bool setsMatch = true;"
         ,"      for (uint k = 0; k < xA.length; ++k) {"
         ,"        bytes32 fromA = xA[k];"
         ,"        bool alsoInXB = false;"
         ,"        for (uint l = 0; l < xB.length; ++l) {"
         ,"          if (fromA == xB[l]) {"
         ,"            alsoInXB = true;"
         ,"            break;"
         ,"          }"
         ,"        }"
         ,"        if (!alsoInXB) {"
         ,"          setsMatch = false;"
         ,"          break;"
         ,"        }"
         ,"      }"
         ,"      if (setsMatch) {"
         ,"        diamondRelation.addPairToMap(p, q);"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return diamondRelation;"
         ,"}"
         ,""
         ,"// Returns a new relation with pairs from src(a) to tgt(b),"
         ,"// if there is a pair (a1, a2) in a and a pair (b1, b2) in b where a2 == b1."
         ,"function composition(Relation a, Relation b) internal returns (Relation) {"
         ,"  bool flipA = a.flipped();"
         ,"  bool flipB = b.flipped();"
         ,"  assertTgtAIsSrcB(a, b);"
         ,""
         ,"  Relation compositionRelation;"
         ,"  compositionRelation.setName(\"compositionRelation\");"
         ,"  compositionRelation.setUnivalent(false);"
         ,"  compositionRelation.setTotal(false);"
         ,"  compositionRelation.setSurjective(false);"
         ,"  compositionRelation.setInjective(false);"
         ,"  compositionRelation.setIsProperty(false);"
         ,"  compositionRelation.setReflexive(false);"
         ,"  compositionRelation.setSymmetric(false);"
         ,"  compositionRelation.setFlipped(false);"
         ,"  compositionRelation.setSource(flipA ? a.target() : a.source());"
         ,"  compositionRelation.setTarget(flipB ? b.source() : b.target());"
         ,"  bytes32[] memory allSourceAtoms = flipA ? a.target().getIds() : a.source().getIds(); // iterate over pairs in a"
         ,"  for(uint i = 0; i < allSourceAtoms.length; ++i) {"
         ,"    bytes32[] memory targetAtomsA = flipA ? a.getSourcesForTarget(allSourceAtoms[i]) : a.getTargetsForSource(allSourceAtoms[i]);"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      bytes32[] memory targetAtomsB = flipB ? b.getSourcesForTarget(allSourceAtoms[j]) : b.getTargetsForSource(allSourceAtoms[j]);"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (findInArray(compositionRelation.getTargetsForSource(allSourceAtoms[i]), targetAtomsB[k]) == -1) {"
         ,"          compositionRelation.addPairToMap(allSourceAtoms[i], targetAtomsB[k]);"
         ,"        }"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return compositionRelation;"
         ,"}"
         ,""
         ,"// Creates a new relation that is a copy of the argument, except flipped."
         ,"function flipped(Relation a) internal returns (Relation) {"
         ,"  Relation flippedA;"
         ,"  copyRelation(a, flippedA);"
         ,"  flippedA.setFlipped(!a.flipped());"
         ,"  return flippedA;"
         ,"}"
         ,""
         ,"function cartesian_product_relation(Concept a, Concept b) internal returns (Relation) {"
         ,"  Relation cp;"
         ,"  cp.setName(\"cartesianProductRelation\");"
         ,"  cp.setUnivalent(false);"
         ,"  cp.setTotal(true);"
         ,"  cp.setSurjective(true);"
         ,"  cp.setInjective(false);"
         ,"  cp.setIsProperty(false);"
         ,"  cp.setReflexive(false);"
         ,"  cp.setSymmetric(true);"
         ,"  cp.setFlipped(false);"
         ,"  cp.setSource(a);"
         ,"  cp.setTarget(b);"
         ,"  for(uint i = 0; i < a.getIds().length; ++i) {"
         ,"    for(uint j = 0; j < b.getIds().length; ++j) {"
         ,"      cp.addPairToMap(a.getIds()[i], b.getIds()[j]);"
         ,"    }"
         ,"  }"
         ,"  return cp;"
         ,"}"
         ,"function view_pAtom(bytes32 id, Concept a) internal returns (Relation) {"
         ,"  Relation singleAtom;"
         ,"  singleAtom.setName(\"view_pAtomRelation\");"
         ,"  singleAtom.setUnivalent(true);"
         ,"  singleAtom.setTotal(false);"
         ,"  singleAtom.setSurjective(false);"
         ,"  singleAtom.setInjective(true);"
         ,"  singleAtom.setIsProperty(true);"
         ,"  singleAtom.setReflexive(false);"
         ,"  singleAtom.setSymmetric(true);"
         ,"  singleAtom.setFlipped(false);"
         ,"  singleAtom.setSource(a);"
         ,"  singleAtom.setTarget(a);"
         ,"  singleAtom.addPairToMap(id, id);"
         ,"  singleAtom.addPairToMap(id, id);"
         ,"  return singleAtom;"
         ,"}"
         ,"// PRESENT BASED ON COMPILATION FROM ADL"
         ,""
         ,"// CONCEPTS:"]
       <>(mconcat . fmap showConcept . Set.toList . instances $ fSpec)
       <>[""
         ,"// RELATIONS:"]
       <>(mconcat . fmap showDecl . Set.toList . instances $ fSpec)
       <>[""
         ,"// RULES:"]
       <>(mconcat . fmap showRule $ zip (Set.toList . instances $ fSpec) [1..])
       <>[""
          ,"function checkRules() internal returns (bool){"]
       <> List.foldr (\i accum -> (Text.pack ("rule" <> show i <>"() &&")) : accum) [] [1::Int ..28] <> [" true;", "}"]
       <>[""
         ,"// CONCEPT METHODS:"]
       <>(mconcat . fmap showConceptMethods . Set.toList . instances $ fSpec)
       <>[""
         ,"//Events"
         ,"  event Error(string _errorMessage);"
         ,"}"]
  where
     fSpec = userFSpec multi
     showConcept :: A_Concept -> [Text.Text]
     showConcept cpt 
       = fmap ("  " <>)
          [""
          ,"// Concept " <> (Text.pack $ showA cpt)
          ,"Concept internal " <> uniqueId fSpec cpt <> " = new Concept({"
          --,"  name: "<> Text.pack (name cpt)
          ,"  _name: " <> (Text.pack . show . name $ cpt) <> ","
          ,"  _ids: new bytes32[](0)"
          ,"});"
          ]
     showConceptMethods :: A_Concept -> [Text.Text]
     showConceptMethods cpt
       = fmap ("  " <>)
       [""
          ,"// Concept " <> (Text.pack $ showA cpt) <> " methods"
          ,"function add" <> uniqueId fSpec cpt <> "(bytes32 id) public {"
          ,"  // TODO CHECK PREVIOUS EXISTENCE"
          ,"  if (findInArray(" <> uniqueId fSpec cpt <> ".getIds(), id) == -1) {"
          ,"    " <> uniqueId fSpec cpt <> ".addId(id);"
          ,"  }"
          ,"  if(!checkRules()){revert();}"
          ,"}"
          ,"function remove" <> uniqueId fSpec cpt <> "(bytes32 id) public {"
          ,"  " <> uniqueId fSpec cpt <> ".removeId(id);"
          ,"  if(!checkRules()){revert();}"
          ,"}"
          ,"function exists" <> uniqueId fSpec cpt <> "(bytes32 id) public view returns (bool) {"
          ,"  return findInArray(" <> uniqueId fSpec cpt <> ".getIds(), id) != -1;"
          ,"}"
       ]
     showDecl :: Relation -> [Text.Text]
     showDecl decl 
        = [""
          ,"// " <> (Text.pack $ showA decl)
          ,"Relation internal " <> uniqueId fSpec decl <> " = new Relation({"
          ,"  _name: " <> (Text.pack . show . name $ decl)<> ","
          ,"  _univalent: "   <> showProp isUni  <> ","
          ,"  _total: "       <> showProp isTot  <> ","
          ,"  _surjective: "  <> showProp isSur  <> ","
          ,"  _injective: "   <> showProp isInj  <> ","
          ,"  _reflexive: "   <> showProp isRfx  <> ","
          ,"  _irreflexive: " <> showProp isIrf  <> ","
          ,"  _transitive: "  <> showProp isTrn  <> ","
          ,"  _symmetric: "   <> showProp isSym  <> ","
          ,"  _asymmetric: "  <> showProp isAsy  <> ","
          ,"  _property: "    <> showProp isProp <> ","
          ,"  _source: "      <> (Text.pack . showA . source $ decl) <> ","
          ,"  _target: "      <> (Text.pack . showA . target $ decl) <> ","
          ,"  _flipped: false" -- initially, no relation is flipped
          ,"});"
          ] 
       where showProp :: (Expression -> Bool) -> Text.Text
             showProp p = Text.toLower . Text.pack . show . p $ EDcD decl
     -- data Expression
--       = EEqu (Expression,Expression)   -- ^ equivalence             =
--       | EInc (Expression,Expression)   -- ^ inclusion               |-
--       | EIsc (Expression,Expression)   -- ^ intersection            /\
--       | EUni (Expression,Expression)   -- ^ union                   \/
--       | EDif (Expression,Expression)   -- ^ difference              -
--       | ELrs (Expression,Expression)   -- ^ left residual           /
--       | ERrs (Expression,Expression)   -- ^ right residual          \
--       | EDia (Expression,Expression)   -- ^ diamond                 <>
--       | ECps (Expression,Expression)   -- ^ composition             ;
--       | ERad (Expression,Expression)   -- ^ relative addition       !
--       | EPrd (Expression,Expression)   -- ^ cartesian product       *
--       | EKl0 Expression                -- ^ Rfx.Trn closure         *  (Kleene star)
--       | EKl1 Expression                -- ^ Transitive closure      +  (Kleene plus)
--       | EFlp Expression                -- ^ conversion (flip, wok)  ~
--       | ECpl Expression                -- ^ Complement
--       | EBrk Expression                -- ^ bracketed expression ( ... )
--       | EDcD Relation               -- ^ simple declaration
--       | EDcI A_Concept                 -- ^ Identity relation
--       | EEps A_Concept Signature       -- ^ Epsilon relation (introduced by the system to ensure we compare concepts by equality only.
--       | EDcV Signature                 -- ^ Cartesian product relation
--       | EMp1 PSingleton A_Concept      -- ^ view PAtomValue, because when building the Expression, the TType of the concept isn't known yet.
--       deriving (Eq, Prelude.Ord, Show, Typeable, Generic, Data)
     showExpression :: Expression -> Text.Text
     showExpression (EEqu (a, b)) = "equivalence(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EInc (a, b)) = "inclusion(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EIsc (a, b)) = "intersection(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EUni (a, b)) = "union(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EDif (a, b)) = "difference(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (ELrs (a, b)) = "left_residual(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (ERrs (a, b)) = "right_residual(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EDia (a, b)) = "diamond(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (ECps (a, b)) = "composition(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (ERad (a, b)) = "relative_addition(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EPrd (a, b)) = "cartesian_product(" <> showExpression a <> ", " <> showExpression b <> ")"

     showExpression (EKl0 e) = "kleene(" <> showExpression e <> ")"
     showExpression (EKl1 e) = "trans_closure(" <> showExpression e <> ")"
     showExpression (EFlp e) = "flipped(" <> showExpression e <> ")"
     showExpression (ECpl e) = "complement(" <> showExpression e <> ")"
     showExpression (EBrk e) = showExpression e
     showExpression (EDcD e) = (Text.pack . name $ e)
     showExpression (EDcI e) = "identity(" <> Text.pack(name $ e) <> ")" --(Text.pack . name $ e)

     showExpression (EEps _ _) = "epsilon(...)"
     showExpression (EDcV s) = "cartesian_product_relation(" <> Text.pack(name $ source s) <> ", " <> Text.pack(name $ target s) <> ")"
     showExpression (EMp1 ps c) = "view_pAtom(" <> Text.pack(show ps) <> ", " <> Text.pack(name $ c) <> ")"

  --   showExpression _ = Text.pack "NOT_YET_IMPLEMENTED" 

     showRule :: (Rule, Int) -> [Text.Text]
     showRule (rule, idx)
        = [""
          ,"//" <> Text.replace "\n" "\n//" (Text.pack $ showA rule)
          ,"function rule" <> (Text.pack $ show idx) <> "() internal returns (bool){"
          ,"  // " <> (Text.pack . show . formalExpression $ rule)
          ,"  " <> (showExpression . formalExpression $ rule) <> ";"
          ,"}"
          ]


class UniqueId a where
  uniqueId :: FSpec -> a -> Text.Text
instance UniqueId A_Concept where
  uniqueId _ cpt = Text.pack (name cpt)
instance UniqueId Relation where
  uniqueId fSpec decl = 
    case Set.toList . Set.filter (\x -> name x == name decl) $ instances fSpec of
      []  -> fatal $ "The declaration must exist in the fSpec" <> showA decl
      [_] -> Text.pack (name decl)
      xs  -> case List.elemIndex decl xs of
              Nothing -> fatal $ "decl should be in this list of decls with the same name!" <> showA decl
              Just i  -> Text.pack (name decl ++ show i)
