{-# LANGUAGE OverloadedStrings #-}
module Ampersand.Output.FSpec2Solidity (fSpec2Solidity)
where
import Ampersand.Basics
import Ampersand.Classes
import Ampersand.Core.AbstractSyntaxTree
import Ampersand.Core.ShowAStruct
import Ampersand.FSpec
import Data.List as List
import Data.Monoid
import Data.Text as Text
-- import Data.List.Utils (replace)

fSpec2Solidity :: MultiFSpecs -> Text.Text
fSpec2Solidity multi =
  Text.intercalate "\n" $
         ["/*"
         ,"This file is generated using " <> (Text.pack ampersandVersionStr)
         ,"*/"
         ,""
         ,"pragma solidity ^0.4.13;"
         ,""
         ,"contract " <> (Text.pack $ show . originalContext $ fSpec) <> " {"
         ,""
         ,"/* ******************************************** Standard structs and functions present in every contract ********************************************** */"
         ,""
         ,"function bytes32ToString(bytes32 x) constant internal returns (string) {"
         ,"  bytes memory bytesString = new bytes(32);"
         ,"  uint charCount = 0;"
         ,"  for (uint j = 0; j < 32; j++) {"
         ,"    byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));"
         ,"    if (char != 0) {"
         ,"      bytesString[charCount] = char;"
         ,"      charCount++;"
         ,"    }"
         ,"  }"
         ,"  bytes memory bytesStringTrimmed = new bytes(charCount);"
         ,"  for (j = 0; j < charCount; j++) {"
         ,"    bytesStringTrimmed[j] = bytesString[j];"
         ,"  }"
         ,"  return string(bytesStringTrimmed);"
         ,"}"
         ,""
         ,"function findInArray(bytes32[] array, bytes32 element) constant internal returns (int) {"
         ,"  // TODO fix overflow vulnerability"
         ,"  for (uint i = 0; i < array.length; ++i) {"
         ,"    if (array[i] == element) {"
         ,"      return int(i);"
         ,"    }"
         ,"  }"
         ,"  return -1;"
         ,"}"
         ,""
         ,"struct Concept {"
         ,"  bytes32 name; // name of the concept"
         ,"  bytes32[] ids; // id's of all the atoms in the concept"
         ,"}"
         ,""
         ,"struct Relation {"
         ,"  bytes32 name;"
         ,"  bool univalent;"
         ,"  bool total;"
         ,"  bool surjective;"
         ,"  bool injective;"
         ,"  bool reflexive;"
         ,"  bool irreflexive;"
         ,"  bool transitive;"
         ,"  bool symmetric;"
         ,"  bool asymmetric;"
         ,"  bool property;"
         ,"  Concept source;"
         ,"  Concept target;"
         ,"  bool flipped;"
         ,"  mapping (bytes32 => bytes32[]) relationMap;"
         ,"  mapping (bytes32 => bytes32[]) relationMapFlip;"
         ,"}"
         ,""
         ,"function copyRelation(Relation storage srcRel, Relation storage tgtRel) internal {"
         ,"  tgtRel.name = srcRel.name;"
         ,"  tgtRel.univalent = srcRel.univalent;"
         ,"  tgtRel.total = srcRel.total;"
         ,"  tgtRel.surjective = srcRel.surjective;"
         ,"  tgtRel.injective = srcRel.injective;"
         ,"  tgtRel.reflexive = srcRel.reflexive;"
         ,"  tgtRel.irreflexive = srcRel.irreflexive;"
         ,"  tgtRel.transitive = srcRel.transitive;"
         ,"  tgtRel.symmetric = srcRel.symmetric;"
         ,"  tgtRel.asymmetric = srcRel.asymmetric;"
         ,"  tgtRel.property = srcRel.property;"
         ,"  tgtRel.source = srcRel.source;"
         ,"  tgtRel.target = srcRel.target;"
         ,"  tgtRel.flipped = srcRel.flipped;"
         ,"  // It would be AMAZING (and a bare minimum requirement"
         ,"  // of any programming language) if we could do the following:"
         ,"  // tgtRel.relationMap = srcRel.relationMap;"
         ,"  // tgtRel.relationMapFlip = srcRel.relationMapFlip;"
         ,"  // However, we need to copy the mapping manually, no reference is possible."
         ,"  bytes32[] sourceAtoms = srcRel.source.ids;"
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    var targetAtoms = srcRel.relationMap[sourceAtoms[i]];"
         ,"    for (uint j = 0; j < targetAtoms.length; ++j) {"
         ,"      tgtRel.relationMap[sourceAtoms[i]].push(targetAtoms[j]);"
         ,"      tgtRel.relationMapFlip[targetAtoms[j]].push(sourceAtoms[i]);"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// verifies that a and b have the same source and target concepts"
         ,"function assertSameTypes(Relation storage a, Relation storage b) constant internal {"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  if (flipA == flipB) {"
         ,"    if (a.source.name != b.source.name || a.target.name != b.target.name) {"
         ,"      Error(\"Error: incompatible types.\");"
         ,"    }"
         ,"  } else { // flipA != flipB, only one is flipped"
         ,"    if (a.source.name != b.target.name || a.target.name != b.source.name) {"
         ,"      Error(\"Error: incompatible types.\");"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// verifies that a's target is b's source concept"
         ,"function assertSrcAIsTgtB(Relation storage a, Relation storage b) constant internal{"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  if (flipA){"
         ,"    if (flipB){"
         ,"      if (sha3(a.source) != sha3(b.target)) {"
         ,"        Error(\"Error: incompatible types, a.source should be b.target.\");"
         ,"      }"
         ,"    } else {"
         ,"      if (sha3(a.source) != sha3(b.source)) {"
         ,"        Error(\"Error: incompatible types, a.source should be b.source.\");"
         ,"      }"
         ,"    }"
         ,"  } else {"
         ,"    if (flipB) {"
         ,"      if (sha3(a.target) != sha3(b.target)) {"
         ,"        Error(\"Error: incompatible types, a.target should be b.target.\");"
         ,"      }"
         ,"    } else {"
         ,"      if (sha3(a.target) != sha3(b.source)) {"
         ,"        Error(\"Error: incompatible types, a.target should be b.source.\");"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"}"
         ,""
         ,"// Return the identity relation, with all atoms mapped only to themselves."
         ,"function identity(Concept storage a) constant internal returns (Relation storage) {"
         ,"  Relation identityRelation;"
         ,"  identityRelation.name = \"identityPerson\";"
         ,"  identityRelation.univalent = true;"
         ,"  identityRelation.total = true;"
         ,"  identityRelation.surjective = true;"
         ,"  identityRelation.injective = true;"
         ,"  identityRelation.property = false;"
         ,"  identityRelation.irreflexive = false;"
         ,"  identityRelation.symmetric = false;"
         ,"  identityRelation.flipped = false;"
         ,"  identityRelation.source = a;"
         ,"  identityRelation.target = a;"
         ,"  "
         ,"  bytes32[] sourceAtoms = a.ids;"
         ,""
         ,"    // find all source-target pairs that are present in both a and b."
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    identityRelation.relationMap[sourceAtoms[i]].push(sourceAtoms[i]);"
         ,"    identityRelation.relationMapFlip[sourceAtoms[i]].push(sourceAtoms[i]);"
         ,"  }"
         ,"  return identityRelation;"
         ,"}"
         ,""
         ,"// Returns true if all pairs of atoms in relation a are also present in relation b, i.e. a is a subset of b."
         ,"function inclusion(Relation storage a, Relation storage b) constant internal returns(bool){"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  assertSameTypes(a, b);"
         ,"  var mappingA = flipA ? a.relationMapFlip : a.relationMap;"
         ,"  var mappingB = flipB ? b.relationMapFlip: b.relationMap;"
         ,""
         ,"  // ALL source atoms in the concept, not just the ones that are \"used\" in the two relations."
         ,"  bytes32[] sourceAtoms = flipA ? a.target.ids : a.source.ids;"
         ,""
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    var targetAtomsA = mappingA[sourceAtoms[i]];"
         ,"    var targetAtomsB = mappingB[sourceAtoms[i]];"
         ,"    // in a, some targets are reached from the current source atom."
         ,"    // we now check if all source-target pairs are also present in b."
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      var matched = false;"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          matched = true;"
         ,"          return false;"
         ,"          continue;"
         ,"        }"
         ,"      }"
         ,"      if (!matched) {"
         ,"        return false;"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return true;"
         ,"}"
         ,""
         ,"function intersection(Relation storage a, Relation storage b) constant internal returns (Relation storage) {"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  assertSameTypes(a, b);"
         ,"  "
         ,"  Relation storage intersectionRelation;"
         ,"  intersectionRelation.name = \"identityPerson\";"
         ,"  intersectionRelation.univalent = false;"
         ,"  intersectionRelation.total = false;"
         ,"  intersectionRelation.surjective = false;"
         ,"  intersectionRelation.injective = false;"
         ,"  intersectionRelation.property = false;"
         ,"  intersectionRelation.irreflexive = false;"
         ,"  intersectionRelation.symmetric = false;"
         ,"  intersectionRelation.flipped = false;"
         ,"  intersectionRelation.source = flipA ? a.target : a.source;"
         ,"  intersectionRelation.target = flipA ? a.source : a.target;"
         ,"  "
         ,"  var mappingA = flipA ? a.relationMapFlip : a.relationMap;"
         ,"  var mappingB = flipB ? b.relationMapFlip: b.relationMap;"
         ,"  bytes32[] sourceAtoms = flipA ? a.target.ids : a.source.ids;"
         ,""
         ,"    // find all source-target pairs that are present in both a and b."
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    var targetAtomsA = mappingA[sourceAtoms[i]];"
         ,"    var targetAtomsB = mappingB[sourceAtoms[i]];"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          intersectionRelation.relationMap[sourceAtoms[i]].push(targetAtomsA[j]);"
         ,"          intersectionRelation.relationMapFlip[targetAtomsA[j]].push(sourceAtoms[i]);"
         ,"        }"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return intersectionRelation;"
         ,"}"
         ,""
         ,"// Returns a new relation with all pairs in a that are not in b."
         ,"function difference(Relation storage a, Relation storage b) constant internal returns (Relation storage) {"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  assertSameTypes(a, b);"
         ,""
         ,"  Relation storage differenceRelation;"
         ,"  differenceRelation.name = \"differenceRelation\";"
         ,"  differenceRelation.univalent = false;"
         ,"  differenceRelation.total = false;"
         ,"  differenceRelation.surjective = false;"
         ,"  differenceRelation.injective = false;"
         ,"  differenceRelation.property = false;"
         ,"  differenceRelation.irreflexive = false;"
         ,"  differenceRelation.symmetric = false;"
         ,"  differenceRelation.flipped = false;"
         ,"  differenceRelation.source = flipA ? a.target : a.source;"
         ,"  differenceRelation.target = flipA ? a.source : a.target;"
         ,""
         ,"  var mappingA = flipA ? a.relationMapFlip : a.relationMap;"
         ,"  var mappingB = flipB ? b.relationMapFlip: b.relationMap;"
         ,"  bytes32[] sourceAtoms = flipA ? a.target.ids : a.source.ids;"
         ,"  // find all pairs that are present in a, but not b."
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    var targetAtomsA = mappingA[sourceAtoms[i]];"
         ,"    var targetAtomsB = mappingB[sourceAtoms[i]];"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      bool alsoInB = false;"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (targetAtomsB[k] == targetAtomsA[j]) {"
         ,"          alsoInB = true;"
         ,"          break;"
         ,"        }"
         ,"      }"
         ,"      if (!alsoInB) {"
         ,"        differenceRelation.relationMap[sourceAtoms[i]].push(targetAtomsA[j]);"
         ,"        differenceRelation.relationMapFlip[targetAtomsA[j]].push(sourceAtoms[i]);"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return differenceRelation;"
         ,"}"
         ,""
         ,"// Returns a new relation with pairs from src(a) to tgt(b),"
         ,"// if there is a pair (a1, a2) in a and a pair (b1, b2) in b where a2 == b1."
         ,"function composition(Relation storage a, Relation storage b) constant internal returns (Relation storage) {"
         ,"  var flipA = a.flipped;"
         ,"  var flipB = b.flipped;"
         ,"  assertSrcAIsTgtB(a, b);"
         ,""
         ,"  Relation storage compositionRelation;"
         ,"  compositionRelation.name = \"compositionRelation\";"
         ,"  compositionRelation.univalent = false;"
         ,"  compositionRelation.total = false;"
         ,"  compositionRelation.surjective = false;"
         ,"  compositionRelation.injective = false;"
         ,"  compositionRelation.property = false;"
         ,"  compositionRelation.irreflexive = false;"
         ,"  compositionRelation.symmetric = false;"
         ,"  compositionRelation.flipped = false;"
         ,"  compositionRelation.source = flipA ? a.target : a.source;"
         ,"  compositionRelation.target = flipB ? b.source : b.target;"
         ,"  var mappingA = flipA ? a.relationMapFlip : a.relationMap;"
         ,"  var mappingB = flipB ? b.relationMapFlip: b.relationMap;"
         ,"  bytes32[] sourceAtoms = flipA ? a.target.ids : a.source.ids; // iterate over pairs in a"
         ,"  for(uint i = 0; i < sourceAtoms.length; ++i) {"
         ,"    var targetAtomsA = mappingA[sourceAtoms[i]];"
         ,"    for(uint j = 0; j < targetAtomsA.length; ++j) {"
         ,"      var targetAtomsB = mappingB[targetAtomsA[j]];"
         ,"      for (uint k = 0; k < targetAtomsB.length; ++k) {"
         ,"        if (findInArray(compositionRelation.relationMap[sourceAtoms[i]], targetAtomsB[k]) == -1) {"
         ,"          compositionRelation.relationMap[sourceAtoms[i]].push(targetAtomsB[k]);"
         ,"          compositionRelation.relationMapFlip[targetAtomsB[k]].push(sourceAtoms[i]);"
         ,"        }"
         ,"      }"
         ,"    }"
         ,"  }"
         ,"  return compositionRelation;"
         ,"}"
         ,""
         ,"// Creates a new relation that is a copy of the argument, except flipped."
         ,"function flipped(Relation storage a) constant internal returns (Relation storage) {"
         ,"  Relation flippedA;"
         ,"  copyRelation(a, flippedA);"
         ,"  flippedA.flipped = a.flipped ? false : true;"
         ,"  return flippedA;"
         ,"}"
         ,""
         ,"// PRESENT BASED ON COMPILATION FROM ADL"
         ,""
         ,"// CONCEPTS:"
         ]
       <>(mconcat . fmap showConcept . allConcepts $ fSpec)
       <>[""
         ,"// RELATIONS:"]
       <>(mconcat . fmap showDecl . vrels $ fSpec)
       <>[""
         ,"// RULES:"]
       <>(mconcat (fmap showRule (List.zip (vrules fSpec) (List.take (List.length $ vrules fSpec) [1,2..]))))
       <>[""
         ,"//Events"
         ,"  event Error(string _errorMessage);"
         ,"}"]
  where
     fSpec = userFSpec multi
     showConcept :: A_Concept -> [Text.Text]
     showConcept cpt 
       = fmap ("  " <>)
          [""
          ,"// Concept " <> (Text.pack$ showA cpt)
          ,"Concept internal " <> uniqueId fSpec cpt <> " = Concept({"
          --,"  name: "<> Text.pack (name cpt)
          ,"  name: " <> (Text.pack . show . name $ cpt) <> ","
          ,"  ids: new bytes32[](0)"
          ,"});"
          ,"function add" <> uniqueId fSpec cpt <> "(bytes32 id) {"
          ,"  // TODO CHECK PREVIOUS EXISTENCE"
          ,"  if (findInArray(" <> uniqueId fSpec cpt <> ".ids, id) == -1) {"
          ,"    " <> uniqueId fSpec cpt <> ".ids.push(id);"
          ,"  }"
          ,"}"
          ,"function remove" <> uniqueId fSpec cpt <> "(bytes32 id) {"
          ,"  uint itemsRemoved = 0;"
          ,"  // first remove all occurrences of id (should occur only once)"
          ,"  for (uint i = 0; i<" <> uniqueId fSpec cpt <> ".ids.length; i++){"
          ,"    if (" <> uniqueId fSpec cpt <> ".ids[i] == id) {"
          ,"      delete(" <> uniqueId fSpec cpt <> ".ids[i]);"
          ,"      ++itemsRemoved;"
          ,"    } else if (itemsRemoved > 0) {"
          ,"      " <> uniqueId fSpec cpt <> ".ids[i - itemsRemoved] = " <> uniqueId fSpec cpt <> ".ids[i];"
          ,"    }"
          ,"  }"
          ,"  if (itemsRemoved == 1) {"
          ,"    // if an item was removed, shrink the ids array by one"
          ,"    delete(" <> uniqueId fSpec cpt <> ".ids[" <> uniqueId fSpec cpt <> ".ids.length - 1]);"
          ,"    --" <> uniqueId fSpec cpt <> ".ids.length;"
          ,"  } else if (itemsRemoved > 0) {"
          ,"    Error(\"" <> uniqueId fSpec cpt <> " ids should have been unique!\");"
          ,"  }"
          ,"}"
          ,"function exists" <> uniqueId fSpec cpt <> "(bytes32 id) constant returns (bool) {"
          ,"  return findInArray(" <> uniqueId fSpec cpt <> ".ids, id) != -1;"
          ,"}"
          ]
     showDecl :: Declaration -> [Text.Text]
     showDecl decl 
        = [""
          ,"// " <> (Text.pack$ showA decl)
          ,"Relation internal " <> uniqueId fSpec decl <> " = Relation({"
          ,"  name: " <> (Text.pack . show . name $ decl)<> ","
          ,"  univalent: "   <> showProp isUni  <> ","
          ,"  total: "       <> showProp isTot  <> ","
          ,"  surjective: "  <> showProp isSur  <> ","
          ,"  injective: "   <> showProp isInj  <> ","
          ,"  reflexive: "   <> showProp isRfx  <> ","
          ,"  irreflexive: " <> showProp isIrf  <> ","
          ,"  transitive: "  <> showProp isTrn  <> ","
          ,"  symmetric: "   <> showProp isSym  <> ","
          ,"  asymmetric: "  <> showProp isAsy  <> ","
          ,"  property: "    <> showProp isProp <> ","
          ,"  source: "      <> (Text.pack . showA . source $ decl) <> ","
          ,"  target: "      <> (Text.pack . showA . target $ decl) <> ","
          ,"  flipped: false" -- initially, no relation is flipped
          ,"});"
          ] 
       where showProp :: (Declaration -> Bool) -> Text.Text
             showProp p = Text.toLower . Text.pack . show . p $ decl
     -- data Expression
--       = EEqu (Expression,Expression)   -- ^ equivalence             =
--       | EInc (Expression,Expression)   -- ^ inclusion               |-
--       | EIsc (Expression,Expression)   -- ^ intersection            /\
--       | EUni (Expression,Expression)   -- ^ union                   \/
--       | EDif (Expression,Expression)   -- ^ difference              -
--       | ELrs (Expression,Expression)   -- ^ left residual           /
--       | ERrs (Expression,Expression)   -- ^ right residual          \
--       | EDia (Expression,Expression)   -- ^ diamond                 <>
--       | ECps (Expression,Expression)   -- ^ composition             ;
--       | ERad (Expression,Expression)   -- ^ relative addition       !
--       | EPrd (Expression,Expression)   -- ^ cartesian product       *
--       | EKl0 Expression                -- ^ Rfx.Trn closure         *  (Kleene star)
--       | EKl1 Expression                -- ^ Transitive closure      +  (Kleene plus)
--       | EFlp Expression                -- ^ conversion (flip, wok)  ~
--       | ECpl Expression                -- ^ Complement
--       | EBrk Expression                -- ^ bracketed expression ( ... )
--       | EDcD Declaration               -- ^ simple declaration
--       | EDcI A_Concept                 -- ^ Identity relation
--       | EEps A_Concept Signature       -- ^ Epsilon relation (introduced by the system to ensure we compare concepts by equality only.
--       | EDcV Signature                 -- ^ Cartesian product relation
--       | EMp1 PSingleton A_Concept      -- ^ constant PAtomValue, because when building the Expression, the TType of the concept isn't known yet.
--       deriving (Eq, Prelude.Ord, Show, Typeable, Generic, Data)
     showExpression :: Expression -> Text.Text
     showExpression (EInc (a, b)) = "inclusion(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EIsc (a, b)) = "intersection(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (ECps (a, b)) = "composition(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression (EDcD d) = (Text.pack . name $ d)
     showExpression (EFlp a) = "flipped(" <> showExpression a <> ")"
     showExpression (EDcI c) = "identity(" <> Text.pack(name $ c) <> ")" --(Text.pack . name $ c)
     showExpression (EDif (a, b)) = "difference(" <> showExpression a <> ", " <> showExpression b <> ")"
     showExpression _ = Text.pack "NOT_YET_IMPLEMENTED"

     showRule :: (Rule, Int) -> [Text.Text]
     showRule (rule, idx)
        = [""
          ,"//" <> replace "\n" "\n//" (Text.pack$ showA rule)
          ,"function rule" <> (Text.pack $ show idx) <> "() constant internal {"
          ,"  // " <> (Text.pack . show . rrexp $ rule)
          ,"  " <> (showExpression . rrexp $ rule) <> ";"
          ,"}"
          ]


class UniqueId a where
  uniqueId :: FSpec -> a -> Text
instance UniqueId A_Concept where
  uniqueId _ cpt = Text.pack (name cpt)   
instance UniqueId Declaration where
  uniqueId fSpec decl = 
    case Prelude.filter (\x -> name x == name decl) (vrels fSpec) of
      []  -> fatal 97 $ "The declaration must exist in the fSpec" <> showA decl
      [_] -> Text.pack (name decl)
      xs  -> case List.elemIndex decl xs of
              Nothing -> fatal 102 $ "decl should be in this list of decls with the same name!" <> showA decl
              Just i  -> Text.pack (name decl ++ show i)
