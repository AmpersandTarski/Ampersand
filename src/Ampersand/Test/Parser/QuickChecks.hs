{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-deprecations #-} --to avoid warning for trace

module Ampersand.Test.Parser.QuickChecks
    ( parserQuickChecks
    ) where

import Ampersand.ADL1.PrettyPrinters(prettyPrint)
import Ampersand.Basics
import Ampersand.Core.ParseTree (P_Context)
import Ampersand.Input.ADL1.CtxError (Guarded(..))
import Ampersand.Test.Parser.ArbitraryTree()
import Ampersand.Test.Parser.ParserTest (parseReparse)
import Test.QuickCheck(Args(..), quickCheckWithResult, Testable, Result(..))
import qualified RIO.Text as T

-- Tries to parse a string, and if successful, tests the result with the given function
testParse :: Text -> (P_Context -> Bool) -> Bool
testParse str check = case parseReparse "File generated by QuickCheck. When you see it in an error, there is something wrong with the parser!" str of
            Checked a _ -> check a
            Errors e    -> trace (tshow e <> "\n" <> str) False
            -- TODO: Errors e  -> do { showErrors e; return False }

-- Tests whether the parsed context is equal to the original one
prop_pretty :: P_Context -> Bool
prop_pretty ctx = testParse prettyCtx eq
        where eq p = ctx == p || trace ("Printed versions are different: " <> prettyCtx <> "\n\n---------\n\n" <> prettyPrint p) False
              prettyCtx = T.unlines 
                        . zipWith (curry includeLineNr) [1 ..] 
                        . T.lines 
                        . prettyPrint $ ctx
              includeLineNr :: (Int,Text) -> Text
              includeLineNr (nr,str) = "{-"<>T.replicate (4 - T.length (tshow nr)) "0"<>tshow nr<>"-} "<>str

checkArgs :: Args
checkArgs = Args
  { replay          = Nothing
  , maxSuccess      = 64
  , maxDiscardRatio = 8
  , maxSize         = 8      -- otherwise there's nothing quick about it.
  , maxShrinks      = 50 
  , chatty          = False
  }

-- TODO: Improve the messages given here, remove all trace's
test :: Testable prop => prop -> RIO env (Bool, Text)
test p = do 
    res <- liftIO $ quickCheckWithResult checkArgs p
    case res of
      Success {} -> return (True, "")
      _          -> return (False, tshow res )

parserQuickChecks :: RIO env (Bool,Text)
parserQuickChecks = test prop_pretty
