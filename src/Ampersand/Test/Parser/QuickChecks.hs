{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-deprecations #-} --to avoid warning for trace

module Ampersand.Test.Parser.QuickChecks
    ( parserQuickChecks
    ) where

import Ampersand.ADL1.PrettyPrinters(prettyPrint)
import Ampersand.Basics
import Ampersand.Core.ParseTree (P_Context)
import Ampersand.Input.Parsing ( parseCtx )
import Ampersand.Input.ADL1.CtxError (Guarded(..))
import Ampersand.Test.Parser.ArbitraryTree()
import Test.QuickCheck(Args(..), quickCheckWithResult, Testable, Result(..),counterexample,property,Property)
import qualified RIO.Text as T

prop_parser :: P_Context -> Property
prop_parser pCtx  =
   case parseCtx "File generated by QuickCheck. When you see it in an error, there is something wrong with the parser!" . prettyCtx $ pCtx of
      Checked (pCtx', _) _  -> property (pCtx == pCtx')
      Errors a  -> counterexample (show a ++ "\n" ++ T.unpack (prettyCtx pCtx)) False
  where
    prettyCtx = T.unlines 
              . zipWith (curry includeLineNr) [1 ..] 
              . T.lines 
              . prettyPrint
    includeLineNr :: (Int,Text) -> Text
    includeLineNr (nr,str) = "{-"<>T.replicate (4 - T.length (tshow nr)) "0"<>tshow nr<>"-} "<>str

checkArgs :: Args
checkArgs = Args
  { replay          = Nothing
  , maxSuccess      = 64
  , maxDiscardRatio = 8
  , maxSize         = 8      -- otherwise there's nothing quick about it.
  , maxShrinks      = 50 
  , chatty          = False
  }

-- TODO: Improve the messages given here, remove all trace's
test :: Testable prop => prop -> RIO env (Bool, Text)
test p = do 
    res <- liftIO $ quickCheckWithResult checkArgs p
    case res of
      Success {} -> return (True, "")
      _          -> return (False, tshow res )

parserQuickChecks :: RIO env (Bool,Text)
parserQuickChecks = test prop_parser
