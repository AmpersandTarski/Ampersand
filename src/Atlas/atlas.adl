CONTEXT Atlas: user;s[User*User];user~ /\ script;s[Script*Script];script~ 
BINDING 
BIND s::User*User. TOPHP "User", 
BIND s::Script*Script. TOPHP "Script"

--QUICK IMPLEMENTATION FOR ATLAS:
--ONLY PHP/SQL select queries are implemented and tested for context expressions
--The context expression MUST be an intersection with all conjuncts of the format (r;s[R*R];r~) where r::Aything->R and s a singleton relation of type R
--r must be explicitly declared for all Concepts in this Context. s must be explicitly declared. 
-- (a DB table will be created for s, but it does not need to be populated while it is not used in any SELECT query)
--PHP binds the concept name of the singleton in the global variable ctxenv
-- ($GLOBALS['ctxenv']=array('User'=>$_REQUEST['User'],'Script'=>$_REQUEST['Script'])) 
{- The generated SELECT query for Atlas
SELECT DISTINCT TODO.`i`, TODO.`i` AS i1
FROM `#TABLE#` AS TODO
WHERE TODO.`script`='".$GLOBALS['ctxenv']['Script']."'
  AND TODO.`user`='".$GLOBALS['ctxenv']['User']."'
-}
--USAGE -> The context expression can be used in composition on all V[Anything*Anything] and I[Anything], like expr;V;expr. When the source or target is ONE, this is not needed, which saves a declaration r::ONE->R.
--Compiletime checks are on context expressions minimal while still only used for Atlas.
--GEN/SPEC is not considered yet, while it does not work properly in PHP at this moment.

--TODO -> WHILE GEN does not work well in prototype it is best to first define relations on 
--specific concept -> general properties are translated into columns at the end, so they can be removed more easily

PATTERN Atlas
picture::Service->Picture.

-- a relation variable can be overloaded -> no function
-- TODO -> namespaces?
relvar::Relation*Type.
contains::Relation*Pair.
contains::Concept*Atom.
description::Relation*Explanation [UNI].
example::Relation->PragmaExample.

source::Type->Concept.
target::Type->Concept.
description::Concept*Explanation [UNI].

--IsaRelation contains only user-defined isa relations, not derived ones
specific::IsaRelation->Concept. 
general::IsaRelation->Concept.
ENDPATTERN
PATTERN Rules

{--SPECIFIC RULE DECLARATIONS--}
--GEN UserRule ISA Rule
--GEN MultiplicityRule ISA Rule
--GEN HomogeneousRule ISA Rule
morphisms::UserRule*Relation.
morphisms::Signal*Relation.
property::MultiplicityRule->Prop.
on::MultiplicityRule->Relation.
property::HomogeneousRule->Prop.
on::HomogeneousRule->Relation.
contains::Signal*Pair.

{--GENERAL RULE DECLARATIONS--}
--GEN Rule ISA Expression
--GEN Morphism ISA Expression
--type::Expression->Type.
type::Rule->Type.
type::UserRule->Type.
type::MultiplicityRule->Type.
type::HomogeneousRule->Type.
type::Signal->Type.
--type::Morphism->Type.
violates::Violation*Rule.
violates::Violation*UserRule.
violates::Violation*MultiplicityRule.
violates::Violation*HomogeneousRule.
explanation::Rule->Explanation.
explanation::UserRule->Explanation.
explanation::MultiplicityRule->Explanation.
explanation::HomogeneousRule->Explanation.
explanation::Signal->Explanation.
picture :: UserRule -> Picture.
ENDPATTERN

PATTERN Pattern
pattern :: Rule -> Pattern.
pattern :: UserRule -> Pattern.
pattern :: Signal -> Pattern.
pattern :: MultiplicityRule -> Pattern. --REMARK -> has not been set (use on;pattern)
pattern :: HomogeneousRule -> Pattern. --REMARK -> has not been set (use on;pattern)
pattern :: Relation -> Pattern.
pattern :: IsaRelation -> Pattern.
picture :: Pattern -> Picture.
ENDPATTERN

PATTERN ViolationAnalysis
--subexpressionOf::SubExpression->Expression.
--GEN Rule ISA Expression
--GEN SubExpression ISA Expression

--KEY subexpr: SubExpression(of:subexpressionOf) 
--TODO -> "KEY" makes of SubExpression an Int in prototype. Where is my subexpression?
--I could replace all SubExpression by SubExpressionId and add idOf::SubExpressionId->SubExpression
--but I do not want this ID, it's an implementation choice
--the implementation could have chosen to actually put a key on both column 'i' and 'subexpressionof' and extend all queries.
subexpressionOf::SubExpression -> UserRule.
contains::SubExpression*Pair.
ENDPATTERN

PATTERN Ordering
--GEN Rule ISA Ordening
next :: UserRule->UserRule.
previous :: UserRule->UserRule.
next :: Signal->Signal.
previous :: Signal->Signal.
ENDPATTERN

PATTERN ExplicitUserContext
s::User*User. 
s::Script*Script. 

user::Picture->User.
user::Relation->User.
user::Type->User.
user::Pair->User.
user::Concept->User.
user::Atom->User.
user::IsaRelation->User.
user::MultiplicityRule->User.
user::HomogeneousRule->User.
user::Prop->User.
user::UserRule->User.
user::Rule->User.
user::Violation->User.
user::Explanation->User.
user::Pattern->User.
user::Service->User.
user::SubExpression->User.
user::Signal->User.
user::PragmaExample->User.
script::Picture->Script.
script::Relation->Script.
script::Type->Script.
script::Pair->Script.
script::Concept->Script.
script::Atom->Script.
script::IsaRelation->Script.
script::MultiplicityRule->Script.
script::HomogeneousRule->Script.
script::Prop->Script.
script::UserRule->Script.
script::Rule->Script.
script::Violation->Script.
script::Explanation->Script.
script::Pattern->Script.
script::Service->Script.
script::SubExpression->Script.
script::Signal->Script.
script::PragmaExample->Script.
ENDPATTERN

PATTERN ExplicitDisplay
--All Atlas concepts need to be qualified identity strings to prevent mixture of adl scripts
display::Picture->String.
display::Relation->String.
display::Type->String.
display::Pair->String.
display::Concept->String.
display::Atom->String.
display::IsaRelation->String.
display::MultiplicityRule->String.
display::HomogeneousRule->String.
display::Prop->String.
display::UserRule->String.
display::Rule->String.
display::Violation->String.
display::Explanation->String.
display::Pattern->String.
display::Service->String.
display::SubExpression->String.
display::Signal->String.
display::PragmaExample->String.
ENDPATTERN

SERVICE Overzicht{"Action=Select"} : I[ONE]
   = [ Patterns{"DISPLAY=Pattern.display"} : V[ONE*Pattern];(user;s;user[Pattern*User]~ /\ script;s;script~) 
        = [ violated_rules{"DISPLAY=UserRule.display"} : pattern[UserRule*Pattern]~;violates~;violates[Violation*UserRule]
         , property_violations_on{"DISPLAY=Relation.display"} : pattern~;on[MultiplicityRule*Relation]~;violates~;violates;on[MultiplicityRule*Relation] \/ pattern~;on[HomogeneousRule*Relation]~;violates~;violates;on[HomogeneousRule*Relation]
          ]
     , "Conceptual diagram"{"PICTURE"}: V[ONE*Service];(user;s;user[Service*User]~ /\ script;s;script~);picture;display
     ]

SERVICE Violations{"Action=Select"}: I[ONE]
   = [ violated_rules{"DISPLAY=UserRule.display"} : V[ONE*Violation];(user;s;user[Violation*User]~ /\ script;s;script~);violates[Violation*UserRule]
        = [ "is violated by" : violates~;display]
     , property_violations_on{"DISPLAY=Relation.display"} : V[ONE*Violation];(user;s;user[Violation*User]~ /\ script;s;script~);violates;on[MultiplicityRule*Relation] \/ V[ONE*Violation];(user;s;user[Violation*User]~ /\ script;s;script~);violates;on[HomogeneousRule*Relation] 
          = [ "is violated by" : on[MultiplicityRule*Relation]~;violates~;display]
     ]

SERVICE Pattern{"Action=Select","DISPLAY=Pattern.display"} : I[Pattern]
   = [ signals{"DISPLAY=Signal.display"} : pattern[Signal*Pattern]~
     , rules{"DISPLAY=UserRule.display"} : pattern[UserRule*Pattern]~
     , relations{"DISPLAY=Relation.display"} : pattern[Relation*Pattern]~
     , isa_relations : pattern[IsaRelation*Pattern]~;display
     , "Conceptual diagram"{"PICTURE"}: picture;display
     ]

-- {"DISPLAY=<Concept>.<(function)Relation>"} if you need the link by id and a user-friendly representation.
--example DISPLAY=Relation.display to print the user-friendly string of a Relation
--TODO -> There are no compile checks to check on the correct type or to check that the relation is represented as a DB column of the table of that type. In case of mistakes the PHP will return a missing offset 0, because it will try to get $rows[0].
--TODO -> DISPLAY has not been tested on all types of ObjectDefs (see Wrapper.hs -> attContent for different patterns)

SERVICE Signal{"Action=Select","DISPLAY=Signal.display"} : I[Signal]
   = [ source{"DISPLAY=Concept.display"} : type;source
     , target{"DISPLAY=Concept.display"} : type;target
     , relations{"DISPLAY=Relation.display"} : morphisms
     , explanation : explanation;display
     , previous{"DISPLAY=Signal.display"} : previous
     , next{"DISPLAY=Signal.display"} : next
     , pattern{"DISPLAY=Pattern.display"} : pattern
     , contains : contains;display]

--TODO -> specific types moeten doorlinken naar generiekere service, als geen specifieke service bestaat
--TODO -> relations op generieke types moeten herkend worden, zodat juiste SQL gemaakt kan worden
--        nu wordt default de specieke tabel gebruikt voor alle relaties!
SERVICE Rule{"Action=Select","DISPLAY=Rule.display"} : I[Rule]
   = [ source{"DISPLAY=Concept.display"} : type;source
     , target{"DISPLAY=Concept.display"} : type;target
     , violations : violates~;display
     , explanation : explanation;display
     , pattern{"DISPLAY=Pattern.display"} : pattern]
SERVICE UserRule{"Action=Select","DISPLAY=UserRule.display"} : I[UserRule]
   = [ source{"DISPLAY=Concept.display"} : type;source
     , target{"DISPLAY=Concept.display"} : type;target
     , relations{"DISPLAY=Relation.display"} : morphisms
     , subexpressions{"DISPLAY=SubExpression.display"}: subexpressionOf~
     , violations : violates~;display
     , explanation : explanation;display
     , previous{"DISPLAY=UserRule.display"} : previous
     , next{"DISPLAY=UserRule.display"} : next
     , pattern{"DISPLAY=Pattern.display"} : pattern
     , "Conceptual diagram"{"PICTURE"}: picture;display]
SERVICE Rule2{"Action=Select","DISPLAY=MultiplicityRule.display"} : I[MultiplicityRule]
   = [ "property of relation"{"DISPLAY=Relation.display"} : on
     , violations : violates~;display
     , explanation : explanation;display
     , pattern{"DISPLAY=Pattern.display"} : on;pattern]
SERVICE Rule3{"Action=Select","DISPLAY=HomogeneousRule.display"} : I[HomogeneousRule]
   = [ "property of relation"{"DISPLAY=Relation.display"} : on
     , violations : violates~;display
     , explanation : explanation;display
     , pattern{"DISPLAY=Pattern.display"} : on;pattern]

SERVICE Population2{"Action=Select","DISPLAY=SubExpression.display"}   : I[SubExpression]
   = [ population  : contains;display]

--I must use a nested name to display, because there is no SERVICE on String only on Relation
SERVICE Relations{"Action=Select"} : I[ONE]
   = [ Relation_s{"DISPLAY=Relation.display"} : V[ONE*Relation];(user;s;user[Relation*User]~ /\ script;s;script~)
        = [ example : example;display]
     ]

--I do not want to display the qualified name, but the unqualified one
--TODO -> in case of overloaded relation variables, the populations are merged 
SERVICE "RelationDetails"{"Action=Select","DISPLAY=Relation.display"}   : I[Relation]
   = [ explanation : description;display
     , "multiplicity properties" : (on[MultiplicityRule*Relation])~
       = [ property : property;display, "derived rule" : display, violations : violates~;display]
     , "homogeneous properties"  : (on[HomogeneousRule*Relation])~
       = [property : property;display, "derived rule" : display, violations : violates~;display]
     , concepts{"DISPLAY=Concept.display"} : relvar;(source \/ target)
     , "used in rules"{"DISPLAY=UserRule.display"} : morphisms[UserRule*Relation]~
     , pattern{"DISPLAY=Pattern.display"} : pattern
     , population  : contains;display
     ]

SERVICE Population{"Action=Select","DISPLAY=Relation.display"}   : I[Relation]
   = [ example : example;display, explanation : description;display, population  : contains;display]

SERVICE Concepts{"Action=Select"} : I[ONE]
   = [ Concept_s{"DISPLAY=Concept.display"} : V[ONE*Concept];(user;s;user[Concept*User]~ /\ script;s;script~)]

SERVICE Concept{"Action=Select","DISPLAY=Concept.display"} : I[Concept]
   = [ description : description;display
     , population : contains;display]

SERVICE "ISArelations"{"Action=Select"} : I[ONE]
   = [ "IS-a relations" :  V[ONE*IsaRelation];(user;s;user[IsaRelation*User]~ /\ script;s;script~)
      = [ "IS-a relation" : display
        , specific {"DISPLAY=Concept.display"}: specific
        , isa {"DISPLAY=Concept.display"}: general
        , pattern : pattern;display
        ]
     ]

ENDCONTEXT

{-

  function display($tbl,$col,$id){
     return firstRow(firstCol(DB_doquer("SELECT DISTINCT `".$col."` FROM `".$tbl."` WHERE `i`='".addslashes($id)."'")));
  }

      <DIV class="FloaterContent"><?php
          $type = $Relation->get_type();
          echo '
          <UL>';
	  foreach($type as $i0=>$idv0){
	    $v0 = display('type','display',$idv0);
            echo '
            <LI CLASS="item UI_type" ID="1.'.$i0.'">';
              if(!$edit) echo '
              <A HREF="'.serviceref('Type', array('Type'=>urlencode($idv0))).'">'.htmlspecialchars($v0).'</A>';
              else echo htmlspecialchars($v0);
            echo '</LI>';
          }


else echo '<H1>'.display('relation','display',$Relation->getId()).'</H1>';
-}

{- Gezocht wordt naar de kolom UserRule, omdat dit zo bepaald is door het
type in de expressie. Maar deze kolom heeft de naam van het generale type Rule, omdat dit zo gedeclareerd is.
Eén of andere join nodig?

SELECT DISTINCT `f1`.`UserRule` AS `id`
FROM  ( SELECT DISTINCT csnd.i AS `UserRule`
FROM `userrule` AS csnd
) AS f1



SELECT DISTINCT 
  `f3`.`UserRule` AS `id`
  ,`f3`.`UserRule` AS `rule`
  , `f3`.`source`
FROM `userrule`
LEFT JOIN  
  ( SELECT DISTINCT F0.`UserRule`, F1.`source`
    FROM `rule` AS F0, `type` AS F1
    WHERE F0.`Type`=F1.`i`
   ) AS f3
ON `f3`.`UserRule`='accepted |- addressedTo~'
WHERE `userrule`.`i`='accepted |- addressedTo~'


SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`UserRule`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`UserRule`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

SELECT DISTINCT 
     'paid |- sentTo~' AS `id` 
   , 'paid |- sentTo~' AS `rule`
   , `f3`.`source` 
FROM `userrule` 
LEFT JOIN 
     ( SELECT DISTINCT 
            F0.`i`
          , F1.`source` 
       FROM `rule` AS F0, `type` AS F1 
       WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='paid |- sentTo~' 
WHERE `userrule`.`i`='paid |- sentTo~'

-------------------------------------
SELECT DISTINCT `f1`.`Violation` AS `violations` FROM `userrule` JOIN `violates` AS f1 ON `f1`.`UserRule`='accepted;of~ |- provided' WHERE `userrule`.`i`='accepted;of~ |- provided'
----------------------------------------------------
SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`MultiplicityRule`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`MultiplicityRule`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'

SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `f2`.`property` 
  , `f3`.`source` 
  , `f4`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN `multiplicityrule` AS f2 
ON `f2`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
LEFT JOIN `multiplicityrule` AS f4 
ON `f4`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'


SELECT DISTINCT 
    'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `id` 
  , `multiplicityrule`.`property` 
  , `f3`.`source` 
  , `multiplicityrule`.`on` 
  , 'sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' AS `rule` 
FROM `multiplicityrule` 
LEFT JOIN 
  ( SELECT DISTINCT 
        F0.`i`
      , F1.`source` 
    FROM `rule` AS F0, `type` AS F1 
    WHERE F0.`Type`=F1.`i` ) AS f3 
ON `f3`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I' 
WHERE `multiplicityrule`.`i`='sentTo[Client*Invoice]~;sentTo[Invoice*Client] |- I'
-}






