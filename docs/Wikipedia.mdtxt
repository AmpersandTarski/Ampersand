This page was prepared as a Wikipedia article draft but rejected.
However, it contains valuable references, so we might use it in our own
documentation.
<TODO: fix all broken links, so we can use it in Docusaurus. Rename to Wikipedia.md, so docusaurus picks it up.>

**Ampersand**[^1] is a [specification language](specification_language "wikilink") that focuses on [information systems](computer_information_systems "wikilink").
Its main purpose is to generate information systems correctly by minimizing the human effort and human mistakes involved in programming.

Ampersand is an instance of [constraint programming](constraint_programming "wikilink")[^2]or [Invariant-based programming](Invariant-based_programming "wikilink").[^3]
After specifying a [data set](data_set "wikilink") structurally as a set of [relations](Relation_(mathematics) "wikilink"), the programmer asserts [constraints](Constraint_(mathematics) "wikilink") on that data set
(Ampersand uses the keyword RULE to specify constraints).
Each constraint serves as an [invariant](Invariant_(computer_science) "wikilink") on the data set,
to be kept satisfied throughout time.
The programmer writes invariants only.
For this reason, the programmer perceives this as specifying rather than programming,
even though the compiler generates working software from an Ampersand script.
The compiler generates all the code needed to execute the specification.

To specify relations together with constraints is equivalent to
specifying an [ontology](Ontology_(information_science) "wikilink")[^4], which is
useful to specify a [domain](Domain_(software_engineering) "wikilink")[^5] formally. An
Ampersand user specifies her constraints in [relation
algebra](relation_algebra "wikilink"), which makes Ampersand suitable
for [automated theorem proving](automated_theorem_proving "wikilink")
and [program analysis](program_analysis "wikilink").

On top of the relations and invariants, the programmer specifies
interfaces that define the functionality of the system.

The Ampersand compiler is available as [free open-source software](Free_and_open-source_software "wikilink") to generate a working application from a specification.
This compiler generates [web applications](web_application "wikilink") and documentation.

Ampersand has been used in practice both in education and industry
(Ordina and TNO-ICT). For example, Ordina designed a proof-of-concept in
2007 of the INDIGO-system. This design was based on Ampersand, to obtain
correct, detailed results in the least amount of time. Today INDIGO is
used as the core information system of the Dutch immigration authority,
IND. More recently, Ampersand was used to design an information system
called DTV for the Dutch Food Authority, NVWA. A prototype of DTV was
built in Ampersand and was used as a model to build the actual system.
TNO-ICT, a major Dutch industrial research laboratory, is using
Ampersand for research purposes. For example, TNO-ICT did a study of
international standardization efforts such as RBAC ([Role-based access
control](Role-based_access_control "wikilink")) in 2003 and architecture
[IEEE 1471-2000](IEEE_1471 "wikilink") in 2004. TNO-ICT has also used
the technique in conceiving several patents, e.g. patents DE60218042D,
WO2006126875, EP1727327, WO2004046848, EP1563361, NL1023394C, EP1420323,
WO03007571, and NL1013450C. The most elaborate information systems in
production, generated by Ampersand, are in the Semantic Treehouse
Project.

At the [Open University of the Netherlands](Open_University_of_the_Netherlands "wikilink"),
Ampersand is being taught in a course called Rule-Based Design. In this course,
students use a platform called RAP, which has been built in
Ampersand[^6]. RAP is the first ever Ampersand generated application
that has run in production.

## Key features

[Declarative](Declarative_programming "wikilink")

  
Ampersand is free of [side effects](side_effects "wikilink"). So, users
can add, update, or delete any rule in the code without affecting other
rules, which makes rules [ composable](Composability "wikilink").
(Opposite: [imperative programming](imperative_programming "wikilink"))
As a consequence, the order of statements does not affect the meaning of
an Ampersand script.

[Reactive](Reactive_programming "wikilink")

  
Ampersand is a reactive[^7] specification language. It does not follow
pre-specified threads of action but reacts to events from outside and
inside the system. Reactive programming sets Ampersand apart from [
single-threaded](Thread_(computing) "wikilink") and [
multi-threaded](Thread_(computing) "wikilink") computing.

[Statically typed](Type_system#STATIC "wikilink")

  
The word static refers to type checking at compile-time. The type system
of Ampersand[^8] presents errors at compile time as type errors, saving
modelers' effort and enhancing the quality of the generated code[^9]
Static type checking is the opposite of [ dynamic type
checking](Type_system#DYNAMIC "wikilink"), which is typically done at
runtime. Ampersand is related to the business rules approach[^10].
However, Ampersand uses constraints for more than decision-making only.
A difference with many other constraint-based languages is the use of
relation algebra rather than [ predicate
logic](First-order_logic "wikilink").

[Relation Algebra](Algebraic_logic#CALCULUS "wikilink")

  
Ampersand is based on Relation Algebra (also known as the [ Calculus of
Relations](Algebraic_logic#CALCULUS "wikilink")) to ensure that business
rules can be defined precisely and that a compiler can generate an
information system. The language uses relation algebra in constraints to
specify invariants. It also uses relation algebra in interfaces to
specify which data is displayed in interface fields.

Composable

  
The schemas of two different Ampersand applications can be combined to
get a new (composed) application. Ampersand allows its users to solve
individual problems in separate efforts, and use composability to put
everything together in the end.

Scientific foundations of Ampersand [^11][^12][^13] have been verified,
peer-reviewed and published in the International Conference on
Relational and Algebraic Methods in Computer Science (RAMiCS) and in the
Journal of Logic and Algebraic Methods in Programming (JLAMP) from 2011
onwards.

## References

## External links

- 

- [Ampersand compiler](https://github.com/AmpersandTarski/Ampersand) at
  [Github](Github "wikilink")

[^1]: Stef Joosten, [Relation Algebra as programming language using the Ampersand compiler](https://www.sciencedirect.com/science/article/pii/S2352220817301499),
    Journal of Logical and Algebraic Methods in Programming,
    Volume 100,
    2018, Pages 113-129, ISSN 2352-2208,
    [1](https://doi.org/10.1016/j.jlamp.2018.04.002).
    Springer.

[^2]: F. Rossi, P. van Beek, and T. Walsh, eds., Handbook of Constraint
    Programming, Elsevier Science, 2006.

[^3]: R_J Back, Invariant based programming: basic approach and teaching
    experiences, Formal Aspects of Computing (2009) 21: 227–244, DOI
    10.1007/s00165-008-0070-y.

[^4]: T. R. Gruber. Toward principles for the design of ontologies used
    for knowledge sharing. Presented at the Padua workshop on Formal
    Ontology, March 1993, later published in International Journal of
    Human-Computer Studies, Vol. 43, Issues 4-5, pp. 907-928, November
    1995.

[^5]: E. Evans, Domain Driven Design: Tackling Complexity in the Heart
    of Software, Addison-Wesley Professional, 2003, ISBN 0321125215.

[^6]: Michels, G., Joosten, S., van der Woude, J., Joosten, S. (2011).
    Ampersand. In: de Swart, H. (eds) Relational and Algebraic Methods
    in Computer Science. RAMICS 2011. Lecture Notes in Computer Science,
    vol 6663. Springer, Berlin, Heidelberg.
    <https://doi.org/10.1007/978-3-642-21070-9_21>

[^7]: Conal Elliott, Paul Hudak, Functional reactive animation,
    Proceedings of the second ACM SIGPLAN international conference on
    Functional programming, ICFP '97, Pages 263–273, August 1997. DOI
    10.1145/258948.258973.

[^8]: Joosten, S.M.M., Joosten, S.J.C. (2015). Type Checking by Domain
    Analysis in Ampersand. In: Kahl, W., Winter, M., Oliveira, J. (eds)
    Relational and Algebraic Methods in Computer Science. RAMICS 2015.
    Lecture Notes in Computer Science, vol 9348, Pages pp 225–240, pub:
    Springer, Cham. <https://doi.org/10.1007/978-3-319-24704-5_14>.

[^9]: Hanenberg, S., Kleinschmager, S., Robbes, R. et al. An empirical
    study on the impact of static typing on software maintainability.
    Empir Software Eng 19, 1335–1382 (2014).
    <https://doi.org/10.1007/s10664-013-9289-1>

[^10]: Lex Wedemeijer, and Jaap van der Woude, [with
    Ampersand/links/5b7321be45851546c903234a/Rule-Based-Design.pdf Rule
    Based
    Design](https://www.researchgate.net/profile/Stef-Joosten/publication/327022933_Rule_Based_Design),
    Open Universiteit Nederland, January 2013, ISBN: 978 94 91825 90 3.
